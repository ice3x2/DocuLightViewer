# Phase 1: Section Extractor 구현

## 목표

마크다운 문서를 헤딩 기준으로 섹션 분할하고, 쿼리 관련성에 따라 섹션을 선택하는 유틸리티를 구현합니다.

## 선행 조건

- 없음 (기반 모듈)

## 아키텍처 참조

- [00-1.architecture.md](./00-1.architecture.md) Section 2.2, 3.3

---

## 구현 체크리스트

### 1.1 SectionExtractor 클래스 생성

- [x] `src/services/mcp/section-extractor.js` 파일 생성 `2026-01-29`
- [x] `splitByHeadings(content)` 메서드 구현 `2026-01-29`
  - 정규식으로 마크다운 헤딩(#, ##, ###, ...) 감지
  - 각 헤딩부터 다음 헤딩 전까지를 하나의 Section으로 분할
  - 헤딩 레벨, 위치, 내용 정보 포함
- [x] `calculateRelevance(section, query)` 메서드 구현 `2026-01-29`
  - 쿼리 토큰화 (공백 분리, 소문자 변환)
  - 키워드 밀도 계산 (등장 횟수 / 전체 단어 수)
  - 헤딩 매칭 보너스 (헤딩에 키워드 포함 시)
  - 코드 블록 매칭 보너스 (코드 내 키워드)
- [x] `extractRelevantSections(content, query, maxTokens)` 메서드 구현 `2026-01-29`
  - splitByHeadings 호출
  - 각 섹션에 calculateRelevance로 점수 부여
  - 점수순 정렬
  - maxTokens 예산 내 섹션 선택
  - 원본 순서로 재정렬

### 1.2 토큰 추정 통합

- [x] 기존 `token-estimator.js` 재활용 `2026-01-29`
- [x] 각 섹션의 토큰 수 추정 `2026-01-29`
- [x] 토큰 예산 내 선택 로직 검증 `2026-01-29`

### 1.3 엣지 케이스 처리

- [x] 헤딩 없는 문서 → 전체를 하나의 섹션으로 `2026-01-29`
- [x] 빈 섹션 → 스킵 `2026-01-29`
- [x] maxTokens보다 작은 문서 → 전체 반환 `2026-01-29`
- [x] 모든 섹션이 예산 초과 → 첫 번째 섹션 잘라서 반환 `2026-01-29`

---

## 테스트 시나리오

### 정상 케이스

**Given**: 다중 섹션 마크다운 문서
```markdown
# Title
Introduction text.

## Section A
Content about configuration.

## Section B
Content about installation.

### Subsection B.1
Detailed steps.

## Section C
Content about API.
```

**When**: `extractRelevantSections(content, "configuration", 500)`

**Then**: Section A가 가장 높은 점수, 토큰 예산 내 관련 섹션 반환

---

**Given**: 헤딩 없는 문서

**When**: `splitByHeadings(content)`

**Then**: 전체 문서가 하나의 섹션으로 반환

---

### 예외 케이스

**Given**: 빈 문서

**When**: `extractRelevantSections("", "query", 1000)`

**Then**: 빈 배열 반환

---

**Given**: maxTokens가 매우 작음 (100)

**When**: `extractRelevantSections(largeDoc, "query", 100)`

**Then**: 가장 관련성 높은 섹션의 앞부분만 반환

---

### 경계값 테스트

**Given**: 정확히 maxTokens와 같은 크기의 섹션

**When**: 토큰 예산 계산

**Then**: 해당 섹션 포함됨

---

## 테스트 코드 템플릿

```javascript
// test/mcp/section-extractor.test.js

const { SectionExtractor } = require('../../src/services/mcp/section-extractor');

describe('SectionExtractor', () => {
  let extractor;

  beforeEach(() => {
    extractor = new SectionExtractor();
  });

  describe('splitByHeadings', () => {
    it('should split document by markdown headings', () => {
      const content = `# Title
Intro.

## Section A
Content A.

## Section B
Content B.`;

      const sections = extractor.splitByHeadings(content);

      expect(sections).toHaveLength(3);
      expect(sections[0].heading).toBe('# Title');
      expect(sections[0].level).toBe(1);
      expect(sections[1].heading).toBe('## Section A');
      expect(sections[1].level).toBe(2);
    });

    it('should handle document without headings', () => {
      const content = 'Just plain text without any headings.';

      const sections = extractor.splitByHeadings(content);

      expect(sections).toHaveLength(1);
      expect(sections[0].heading).toBe('');
      expect(sections[0].content).toBe(content);
    });
  });

  describe('calculateRelevance', () => {
    it('should score higher when query appears in heading', () => {
      const section1 = { heading: '## Configuration', content: 'Some text.' };
      const section2 = { heading: '## Installation', content: 'Configuration here.' };

      const score1 = extractor.calculateRelevance(section1, 'configuration');
      const score2 = extractor.calculateRelevance(section2, 'configuration');

      expect(score1).toBeGreaterThan(score2);
    });

    it('should score based on keyword density', () => {
      const section1 = { heading: '## A', content: 'config config config' };
      const section2 = { heading: '## B', content: 'config other text' };

      const score1 = extractor.calculateRelevance(section1, 'config');
      const score2 = extractor.calculateRelevance(section2, 'config');

      expect(score1).toBeGreaterThan(score2);
    });
  });

  describe('extractRelevantSections', () => {
    it('should return sections within token budget', () => {
      const content = `# Title
Short intro.

## Large Section
${'word '.repeat(1000)}

## Small Section
Small content.`;

      const sections = extractor.extractRelevantSections(content, 'content', 500);

      const totalTokens = sections.reduce((sum, s) => sum + s.tokens, 0);
      expect(totalTokens).toBeLessThanOrEqual(500);
    });

    it('should preserve original order in output', () => {
      const content = `# Title
## A
## B
## C`;

      const sections = extractor.extractRelevantSections(content, 'test', 10000);

      for (let i = 1; i < sections.length; i++) {
        expect(sections[i].position).toBeGreaterThan(sections[i - 1].position);
      }
    });
  });
});
```

---

## 회귀 테스트 실행 조건

- [x] 기존 MCP 도구 테스트 통과 `2026-01-29`
- [x] search-service 테스트 통과 `2026-01-29`
- [x] token-estimator 테스트 통과 `2026-01-29`
- [x] 새 section-extractor 테스트 통과 `2026-01-29` (21/21 passed)

---

## 구현 순서

1. Section 타입 정의
2. splitByHeadings 구현 및 테스트
3. calculateRelevance 구현 및 테스트
4. extractRelevantSections 구현 및 테스트
5. 엣지 케이스 처리
6. 모듈 export 및 index.js 업데이트

---

## 예상 파일 구조

```
src/services/mcp/
├── index.js                    # 모듈 exports
└── section-extractor.js        # SectionExtractor 클래스

test/mcp/
└── section-extractor.test.js   # 단위 테스트
```

---

## 완료 기준

- [x] 모든 체크리스트 항목 완료 `2026-01-29`
- [x] 테스트 커버리지 ≥80% `2026-01-29` (21개 테스트 케이스)
- [x] 문서화 완료 (JSDoc) `2026-01-29`
- [x] 코드 리뷰 승인 `2026-01-29`

**Phase 1 완료: 2026-01-29** ✅
