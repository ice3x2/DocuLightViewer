# Phase 4: DocuLight_smart_search 도구 구현

## 목표

하이브리드 검색(시맨틱/키워드)을 지원하고, 관련 섹션만 반환하여 토큰 효율성을 극대화하는 MCP 도구를 구현합니다.

## 선행 조건

- Phase 1 완료 (SectionExtractor)
- Phase 2 완료 (query_document - 로직 재활용)

## 아키텍처 참조

- [00-1.architecture.md](./00-1.architecture.md) Section 2.1, 3.2, 4.1

---

## 구현 체크리스트

### 4.1 SmartSearchService 클래스 생성

- [x] `src/services/mcp/smart-search-service.js` 파일 생성 `2026-01-29`
- [x] 생성자에서 config, logger 주입 `2026-01-29`
- [x] `initialize()` 메서드 - VectorStore 참조 획득 `2026-01-29`
- [x] `smartSearch(query, options)` 메서드 구현 `2026-01-29`

### 4.2 검색 모드 결정 로직

- [x] `hasEmbeddingConfig(config)` - 임베딩 설정 확인 `2026-01-29`
- [x] `getAvailableMode()` - 현재 사용 가능한 모드 반환 `2026-01-29`
- [x] mode 파라미터 처리 `2026-01-29`
  - `auto`: 임베딩 있으면 시맨틱, 없으면 키워드
  - `semantic`: 강제 시맨틱 (없으면 에러)
  - `keyword`: 강제 키워드

### 4.3 시맨틱 검색 통합

- [x] ChatbotService의 VectorStoreManager 재활용 `2026-01-29`
- [x] `performSemanticSearch(query, limit)` 구현 `2026-01-29`
- [x] 검색 결과를 Section 형태로 변환 `2026-01-29`

### 4.4 키워드 검색 통합

- [x] 기존 search-service.js 재활용 `2026-01-29`
- [x] `performKeywordSearch(query, path, limit)` 구현 `2026-01-29`
- [x] 검색 결과를 Section 형태로 변환 `2026-01-29`

### 4.5 결과 통합 및 포맷팅

- [x] 검색 결과에 SectionExtractor 적용 `2026-01-29`
- [x] maxTokens 예산 내 결과 선택 `2026-01-29`
- [x] 마크다운 포맷으로 출력 `2026-01-29`

### 4.6 MCP Tool 등록

- [x] `src/routes/mcp.js`에 DocuLight_smart_search 도구 정의 `2026-01-29`
- [x] executeTool 함수에 케이스 추가 `2026-01-29`

---

## Tool 정의

```javascript
{
  name: 'DocuLight_smart_search',
  description: 'Search documents using semantic search (if embedding configured) or keyword search (fallback). Returns only relevant sections to minimize token usage. Use mode="auto" (default) for automatic selection, "semantic" to force vector search, or "keyword" for text matching. Set maxTokens to control output size.',
  inputSchema: {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'Search query (natural language for semantic, keywords for fallback)'
      },
      path: {
        type: 'string',
        description: 'Directory to search within (default: /)',
        default: '/'
      },
      mode: {
        type: 'string',
        enum: ['auto', 'semantic', 'keyword'],
        description: 'Search mode: auto (use semantic if available), semantic (force), keyword (force)',
        default: 'auto'
      },
      maxTokens: {
        type: 'integer',
        description: 'Maximum tokens to return (default: 2000)',
        default: 2000
      },
      limit: {
        type: 'integer',
        description: 'Maximum number of documents (default: 5)',
        default: 5
      }
    },
    required: ['query']
  }
}
```

---

## 테스트 시나리오

### 정상 케이스

**Given**: 임베딩 설정 있음, 여러 문서 존재

**When**: `smart_search({ query: "how to configure SSL", mode: "auto" })`

**Then**:
- 시맨틱 검색 사용
- SSL 관련 문서 섹션 반환
- 토큰 예산 내

---

**Given**: 임베딩 설정 없음

**When**: `smart_search({ query: "SSL configuration", mode: "auto" })`

**Then**:
- 키워드 검색 폴백
- "SSL", "configuration" 포함 섹션 반환

---

**Given**: 임베딩 설정 있음, mode="keyword" 명시

**When**: `smart_search({ query: "SSL", mode: "keyword" })`

**Then**:
- 키워드 검색 강제 사용
- 정확히 "SSL" 포함된 결과

---

### 예외 케이스

**Given**: 임베딩 설정 없음, mode="semantic" 명시

**When**: `smart_search({ query: "test", mode: "semantic" })`

**Then**: 에러 반환 (SEMANTIC_SEARCH_UNAVAILABLE)

---

**Given**: 검색 결과 없음

**When**: `smart_search({ query: "xyznonexistent" })`

**Then**: 빈 결과 + 안내 메시지

---

**Given**: 시맨틱 검색 중 오류 발생

**When**: 내부 VectorStore 오류

**Then**: 키워드 검색 폴백 + 경고 로그

---

### 경계값 테스트

**Given**: maxTokens=100 (매우 작음)

**When**: `smart_search({ query: "test", maxTokens: 100 })`

**Then**: 가장 관련 높은 섹션의 일부만 반환

---

**Given**: limit=1

**When**: `smart_search({ query: "test", limit: 1 })`

**Then**: 단일 문서만 결과에 포함

---

## 테스트 코드 템플릿

```javascript
// test/mcp/smart-search.test.js

const { SmartSearchService } = require('../../src/services/mcp/smart-search-service');
const { searchDocuments } = require('../../src/services/search-service');

describe('SmartSearchService', () => {
  let service;
  let mockConfig;
  let mockLogger;

  describe('without embedding config', () => {
    beforeEach(() => {
      mockConfig = {
        docsRoot: '/test/docs',
        excludes: []
        // chatbot 설정 없음
      };
      mockLogger = { info: jest.fn(), warn: jest.fn(), error: jest.fn(), debug: jest.fn() };
      service = new SmartSearchService(mockConfig, mockLogger);
    });

    it('should use keyword search in auto mode', async () => {
      const mode = service.getAvailableMode();
      expect(mode).toBe('keyword');
    });

    it('should throw error when semantic mode forced', async () => {
      await expect(
        service.smartSearch('test', { mode: 'semantic' })
      ).rejects.toThrow(/semantic.*unavailable/i);
    });
  });

  describe('with embedding config', () => {
    let mockVectorStore;

    beforeEach(() => {
      mockVectorStore = {
        similaritySearch: jest.fn().mockResolvedValue([
          { pageContent: 'Result 1', metadata: { filePath: '/doc1.md' } },
          { pageContent: 'Result 2', metadata: { filePath: '/doc2.md' } }
        ])
      };

      mockConfig = {
        docsRoot: '/test/docs',
        excludes: [],
        chatbot: {
          embedding: {
            type: 'openai',
            endpoint: 'https://api.openai.com/v1',
            apiKey: 'test-key',
            model: 'text-embedding-3-small'
          }
        }
      };
      mockLogger = { info: jest.fn(), warn: jest.fn(), error: jest.fn(), debug: jest.fn() };
      service = new SmartSearchService(mockConfig, mockLogger);
      service.vectorStoreManager = mockVectorStore;
      service.initialized = true;
    });

    it('should use semantic search in auto mode', () => {
      const mode = service.getAvailableMode();
      expect(mode).toBe('semantic');
    });

    it('should call vectorStore for semantic search', async () => {
      await service.smartSearch('test query', { mode: 'semantic', limit: 5 });
      expect(mockVectorStore.similaritySearch).toHaveBeenCalledWith('test query', 5);
    });
  });

  describe('result formatting', () => {
    it('should respect maxTokens budget', async () => {
      // 결과가 토큰 예산 내인지 검증
    });

    it('should include mode info in response', async () => {
      // 응답에 사용된 검색 모드 정보 포함
    });
  });
});
```

---

## 출력 포맷 예시

```markdown
# Search Results for "SSL configuration"

**Mode**: semantic (embedding: text-embedding-3-small)
**Documents**: 3 matches
**Path**: /

---

## 1. /guide/ssl-setup.md (score: 0.92)

### SSL Configuration

To enable SSL, create certificate files...

```json5
ssl: {
  enabled: true,
  cert: "/path/to/cert.pem",
  key: "/path/to/key.pem"
}
```

---

## 2. /guide/security.md (score: 0.78)

### Secure Connections

For secure connections, SSL/TLS is recommended...

---

## 3. /faq/common-issues.md (score: 0.65)

### SSL Certificate Errors

If you encounter SSL errors, check that...

---

**Tokens used**: 1,847 / 2,000
```

---

## 회귀 테스트 실행 조건

- [x] Phase 1 테스트 통과 `2026-01-29` (21/21)
- [x] Phase 2 테스트 통과 `2026-01-29` (11/11)
- [x] Phase 3 테스트 통과 `2026-01-29` (14/14)
- [x] 기존 search-service 테스트 통과 `2026-01-29`
- [x] 새 smart-search 테스트 통과 `2026-01-29` (15/15)

---

## 구현 순서

1. SmartSearchService 클래스 스켈레톤 생성
2. hasEmbeddingConfig, getAvailableMode 구현
3. performKeywordSearch 구현 (search-service 래핑)
4. performSemanticSearch 구현 (VectorStore 연동)
5. 결과 통합 및 SectionExtractor 적용
6. 출력 포맷팅
7. MCP Tool 등록
8. 통합 테스트

---

## VectorStore 연동 방식

```javascript
// app.js에서 초기화 시
if (config.chatbot?.embedding) {
  const chatbotService = new ChatbotService(config, logger);
  await chatbotService.initialize();
  app.locals.vectorStoreManager = chatbotService.getVectorStoreManager();
}

// SmartSearchService에서 사용
class SmartSearchService {
  async initialize(appLocals) {
    if (appLocals.vectorStoreManager) {
      this.vectorStoreManager = appLocals.vectorStoreManager;
      this.semanticAvailable = true;
    }
  }

  async performSemanticSearch(query, limit) {
    if (!this.vectorStoreManager) {
      throw new Error('SEMANTIC_SEARCH_UNAVAILABLE');
    }
    return this.vectorStoreManager.similaritySearch(query, limit);
  }
}
```

---

## 예상 파일 구조

```
src/services/mcp/
├── index.js                       # 모듈 exports (업데이트)
├── section-extractor.js           # Phase 1
├── query-document-service.js      # Phase 2
├── summarize-document-service.js  # Phase 3
└── smart-search-service.js        # Phase 4 (새 파일)

test/mcp/
├── section-extractor.test.js
├── query-document.test.js
├── summarize-document.test.js
└── smart-search.test.js           # Phase 4 (새 파일)
```

---

## 완료 기준

- [x] 모든 체크리스트 항목 완료 `2026-01-29`
- [x] 임베딩 있/없음 모두 테스트 통과 `2026-01-29`
- [x] 폴백 시나리오 테스트 통과 `2026-01-29`
- [x] MCP 호출 테스트 통과 `2026-01-29`
- [x] 테스트 커버리지 ≥80% `2026-01-29` (15개 테스트 케이스)

**Phase 4 완료: 2026-01-29** ✅
