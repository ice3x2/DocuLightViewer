# Phase 4: Auto-close 타이머

## 목표

- FR-19-004: `autoCloseSeconds` 파라미터로 지정 시간 후 창 자동 닫기 + 렌더러 카운트다운 UI 표시

## 선행 조건

- Phase 1~3 완료 (WindowEntry.meta 구조, IPC 패턴 확립)
- `src/main/window-manager.js` — `_onWindowClosed()` 훅 확인
- `src/renderer/viewer.js` — IPC 이벤트 수신 패턴 확인
- `src/locales/*.json` (4개) — i18n 키 추가 대상

## 구현 체크리스트

### 1. window-manager.js — Auto-close 타이머 관리 (FR-19-004)

- [x] `createWindow(opts)` 수정 — autoCloseSeconds 처리:
  - `opts.autoCloseSeconds` 있으면:
    - `Math.floor(opts.autoCloseSeconds)` 적용
    - `entry.meta.autoCloseTimer = setTimeout(() => this.closeWindow(windowId), seconds * 1000)`
    - `entry.win.webContents.send('auto-close-start', { seconds: Math.floor(opts.autoCloseSeconds) })`
    - `meta.autoCloseSeconds = Math.floor(opts.autoCloseSeconds)` 저장
- [x] `updateWindow(windowId, opts)` 수정 — 타이머 재설정:
  - `opts.autoCloseSeconds` 있으면:
    - 기존 `clearTimeout(entry.meta.autoCloseTimer)`
    - 새 타이머 등록 (동일 로직)
- [x] `_onWindowClosed(windowId)` 수정 — 타이머 누수 방지:
  - `if (entry.meta.autoCloseTimer) clearTimeout(entry.meta.autoCloseTimer)`
  - `entry.meta.autoCloseTimer = undefined`
- [x] `meta.autoCloseTimer` 초기값 `undefined` 설정

### 2. index.js — IPC 핸들러 파라미터 확장

- [x] `open` 액션 핸들러:
  - `autoCloseSeconds` 파라미터 수신
  - 검증: `< 1` 또는 `> 3600` → error 응답
  - 비정수 → `Math.floor()` 후 전달
- [x] `update` 액션 핸들러:
  - `autoCloseSeconds` 수신, 동일 검증 후 전달

### 3. mcp-http.mjs — TOOLS 스키마 업데이트

- [x] `open_markdown` tool 에 추가:
  ```json
  "autoCloseSeconds": { "type": "integer", "minimum": 1, "maximum": 3600, "description": "Auto-close window after N seconds" }
  ```
- [x] `update_markdown` tool 에 `autoCloseSeconds` 추가 (타이머 재설정)
- [x] 핸들러에서 검증 및 로직 구현

### 4. mcp-server.mjs — Zod 스키마 업데이트

- [x] `open_markdown`, `update_markdown` Zod 스키마에 추가:
  ```javascript
  autoCloseSeconds: z.number().int().min(1).max(3600).optional()
  ```
- [x] 핸들러 로직 동기화

### 5. viewer.js — auto-close-start IPC 처리 (FR-19-004)

- [x] `window.doclight.onAutoCloseStart` 또는 `ipcRenderer.on('auto-close-start', ...)` 수신 핸들러:
  ```javascript
  let autoCloseInterval = null;
  function startAutoCloseCountdown(seconds) {
    const bar = document.getElementById('auto-close-bar');
    if (!bar) return;
    bar.style.display = 'block';
    let remaining = seconds;
    function update() {
      bar.textContent = /* i18n */ `자동 종료: ${remaining}초`;
      bar.style.background = remaining <= 5 ? '#f59e0b' : '';
    }
    update();
    autoCloseInterval = setInterval(() => {
      remaining--;
      if (remaining <= 0) {
        clearInterval(autoCloseInterval);
        return;
      }
      update();
    }, 1000);
  }
  ```
- [x] 기존 autoCloseInterval이 있으면 clearInterval 후 재시작 (update_markdown 재설정 시)
- [x] i18n 처리: `t('viewer.autoCloseLabel', { seconds: n })` 방식 적용

### 6. viewer.css — auto-close-bar 스타일

- [x] `#auto-close-bar` 또는 `.auto-close-bar` 스타일:
  ```css
  #auto-close-bar {
    display: none;
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 28px;
    line-height: 28px;
    text-align: center;
    font-size: 12px;
    background: rgba(0,0,0,0.75);
    color: #fff;
    z-index: 9998;
    transition: background 0.3s;
  }
  ```
- [x] 5초 이하 강조: 배경 `#f59e0b` (주황)

### 7. viewer.html — auto-close-bar 요소 추가

- [x] `<body>` 내 `<div id="auto-close-bar"></div>` 추가

### 8. 로케일 파일 — i18n 키 추가

- [x] `src/locales/ko.json`: `"viewer.autoCloseLabel": "자동 종료: {seconds}초"`
- [x] `src/locales/en.json`: `"viewer.autoCloseLabel": "Auto-close in {seconds}s"`
- [x] `src/locales/ja.json`: `"viewer.autoCloseLabel": "自動終了: {seconds}秒"`
- [x] `src/locales/es.json`: `"viewer.autoCloseLabel": "Cierre automático: {seconds}s"`

## 테스트 시나리오

### 정상 케이스 1: Auto-close 타이머 동작
- **Given**: 없음
- **When**: `open_markdown { autoCloseSeconds: 5, content: "..." }` 호출
- **Then**:
  - 창 하단에 "자동 종료: 5초" 카운트다운 표시
  - 1초마다 카운트 감소
  - 5초 후 창 자동 닫힘

### 정상 케이스 2: 수동 닫기 시 타이머 해제
- **Given**: autoCloseSeconds: 60 으로 열린 창 (windowId: X)
- **When**: 사용자가 창을 수동으로 닫음
- **Then**: `clearTimeout(meta.autoCloseTimer)` 호출, 이후 에러 없음

### 정상 케이스 3: update_markdown으로 타이머 재설정
- **Given**: autoCloseSeconds: 30 으로 열린 창 (15초 경과)
- **When**: `update_markdown { windowId: X, autoCloseSeconds: 60 }` 호출
- **Then**: 기존 타이머 해제, 새 60초 타이머 시작, 카운트다운 60으로 재시작

### 정상 케이스 4: 남은 시간 5초 이하 강조
- **Given**: autoCloseSeconds: 10 으로 열린 창
- **When**: 5초 경과 (남은 시간 5초)
- **Then**: 카운트다운 바 배경이 주황으로 변경

### 예외 케이스 1: autoCloseSeconds < 1
- **Given**: `autoCloseSeconds: 0`
- **Then**: isError 반환

### 예외 케이스 2: autoCloseSeconds > 3600
- **Given**: `autoCloseSeconds: 3601`
- **Then**: isError 반환

### 예외 케이스 3: 비정수 값
- **Given**: `autoCloseSeconds: 5.7`
- **Then**: `Math.floor(5.7) = 5` 로 처리, 정상 동작

### 경계값: autoCloseSeconds = 1
- **Given**: `autoCloseSeconds: 1`
- **Then**: 1초 후 창 자동 닫힘, 카운트다운 바 즉시 강조(5초 이하)

## 회귀테스트 실행 조건

- [x] Phase 1~3 기능 정상 동작
- [x] `autoCloseSeconds` 미지정 창은 카운트다운 바 미표시
- [x] 기존 창 닫기 동작 정상 (타이머 없는 창 닫아도 에러 없음)
- [x] 4개 로케일 모두 카운트다운 텍스트 정상 표시
