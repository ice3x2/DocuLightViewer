# Tech Decisions: DocLight Step 19

## ADR-001: Named Window 식별자로 Map 사용

**결정**: `nameToId: Map<string, number>` 을 WindowManager 클래스 필드로 추가

**근거**:
- Map은 O(1) 조회/삭제, 문자열 키 안전 (prototype 오염 없음)
- 기존 `windows: Map<number, entry>` 패턴과 일관
- 창 소멸 시 `_onWindowClosed()`에서 즉시 정리 가능

**대안**: windows Map에서 meta.windowName 순회 검색 — O(n), 창 수 증가 시 성능 저하 가능

---

## ADR-002: Severity를 data-attribute + CSS로 구현

**결정**: `document.body.setAttribute('data-severity', value)` + CSS `[data-severity="error"]`

**근거**:
- JS 없이 CSS 하나로 모든 severity 색상 처리
- 테마(light/dark) 변경 시 CSS 변수 오버라이드 가능
- 렌더러 상태 최소화 (별도 변수 불필요)

**대안**: classList 토글 — severity 수 증가 시 클래스 관리 복잡

---

## ADR-003: Auto-close 타이머를 메인 프로세스에서 관리

**결정**: `setTimeout(() => closeWindow(id), ms)` 를 Main 프로세스(window-manager.js)에서 실행

**근거**:
- 렌더러 리로드/비정상 종료 시에도 타이머 동작 보장
- `clearTimeout`을 `_onWindowClosed()` 훅에서 확실히 호출 가능
- 렌더러는 카운트다운 UI(표시 목적)만 담당

**대안**: 렌더러에서 setTimeout — 렌더러 크래시 시 타이머 누수

---

## ADR-004: Append 모드 콘텐츠를 in-memory로만 관리

**결정**: `entry.meta.lastRenderedContent` 에 원시 Markdown을 메모리에만 저장, 영속화 없음

**근거**:
- SRS 5.2: "앱 비정상 종료 시 lastRenderedContent 손실 허용 (in-memory)"
- 영속화 시 스토리지 설계 복잡도 및 보안 위험 증가
- 로그 스트리밍 시나리오에서 재시작 시 재전송이 일반적

**제약**: 앱 재시작 시 append 히스토리 초기화

---

## ADR-005: Window Tags를 문자열 배열로 저장

**결정**: `entry.meta.tags: string[]`, 갱신 시 전체 교체 방식

**근거**:
- 단순 읽기/교체 패턴 — 부분 수정 필요 없음
- SRS 2.5.3: "기존 태그 교체(전체 교체 방식)" 명시
- Array.includes()로 O(n) 필터링 — 태그 수(최대 10개) 작아 허용 범위

---

## ADR-006: Flash 실패(Linux) 시 무시 처리

**결정**: `try { entry.win.flashFrame(true) } catch (e) { console.warn(...) }` — MCP 응답은 정상 반환

**근거**:
- SRS 2.6.5: "에러 발생 시 catch 후 console.warn만 출력, MCP 응답은 정상"
- 플래시 실패가 비즈니스 로직 실패는 아님

---

## ADR-007: Progress Bar 값 범위 및 특수값

**결정**: `progress: -1`은 제거 시그널, `0.0 ~ 1.0`은 퍼센트

**근거**:
- Electron `win.setProgressBar()` 공식 API: `-1` = 제거, `0~1` = 비율
- SRS 2.7.3 직접 매핑 → 추가 변환 불필요

---

## ADR-008: separator 기본값 `"\n\n"`

**결정**: Append 모드 기본 구분자를 Markdown 단락 구분자 `"\n\n"`으로 설정

**근거**:
- Markdown에서 `\n\n`은 단락 분리 → 시각적으로 명확한 구분
- 사용자가 커스텀 구분자(`"---"`, `"\n"` 등) 지정 가능

---

## 외부 라이브러리 변경 없음

Step 19는 신규 npm 패키지를 추가하지 않는다.
모든 구현은 Electron 내장 API(`flashFrame`, `setProgressBar`, `webContents.send`)와
Node.js 내장 함수(`setTimeout`, `clearTimeout`)만 사용한다.
