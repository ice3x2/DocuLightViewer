# Phase 5: Append 모드

## 목표

- FR-19-002: `update_markdown { appendMode: true }` 로 기존 콘텐츠 뒤에 새 콘텐츠 이어 붙이기

## 선행 조건

- Phase 1~4 완료
- `updateWindow()` 파라미터 확장 패턴 확립
- `entry.meta.lastRenderedContent` 필드 확인 (Phase 1에서 meta 구조 확립)

## 구현 체크리스트

### 1. window-manager.js — lastRenderedContent 관리 (FR-19-002)

- [x] `createWindow(opts)` 수정 — content 저장:
  - content 기반 창(filePath 없음) 생성 시 `meta.lastRenderedContent = opts.content || ''`
  - filePath 기반 창은 `meta.lastRenderedContent = undefined` (append 불가)
- [x] `updateWindow(windowId, opts)` 수정 — Append 모드 처리:
  ```javascript
  if (opts.appendMode) {
    // filePath 창 → 에러
    if (entry.meta.filePath) {
      return { isError: true, message: 'appendMode is not supported for file-based windows.' };
    }
    // content 필수
    if (!opts.content) {
      return { isError: true, message: 'content is required for appendMode.' };
    }
    // 누적 크기 검증
    const separator = opts.separator ?? '\n\n';
    const existing = entry.meta.lastRenderedContent || '';
    const newContent = existing + separator + opts.content;
    if (Buffer.byteLength(newContent, 'utf8') > 10 * 1024 * 1024) {
      return { isError: true, message: 'Accumulated content exceeds 10MB limit.' };
    }
    opts = { ...opts, content: newContent, appendMode: false };
  }
  ```
- [x] content 기반 `updateWindow()` 성공 시 `meta.lastRenderedContent` 갱신:
  - `entry.meta.lastRenderedContent = opts.content`
- [x] filePath 기반 `updateWindow()` 시 `meta.lastRenderedContent` 갱신 없음
- [x] `meta.lastRenderedContent` 초기값 `undefined` 설정

### 2. index.js — IPC 핸들러 파라미터 확장

- [x] `update` 액션 핸들러:
  - `appendMode` (boolean, 기본 false), `separator` (string, 기본 `"\n\n"`) 파라미터 수신
  - appendMode 검증:
    - `appendMode: true` 이고 `filePath` 기반 창 → error 응답
    - `appendMode: true` 이고 `content` 없음 → error 응답
  - windowManager.updateWindow()에 전달

### 3. mcp-http.mjs — TOOLS 스키마 업데이트

- [x] `update_markdown` tool 에 추가:
  ```json
  "appendMode": { "type": "boolean", "default": false, "description": "Append content to existing window content" },
  "separator": { "type": "string", "default": "\n\n", "description": "Separator between existing and new content" }
  ```
- [x] 핸들러에서 append 모드 로직 구현 (filePath 창 체크, 10MB 한도 체크)
- [x] 성공 응답: `"Appended to window X.\n  title: ..."`
- [x] 에러 응답들 처리

### 4. mcp-server.mjs — Zod 스키마 업데이트

- [x] `update_markdown` Zod 스키마에 추가:
  ```javascript
  appendMode: z.boolean().default(false),
  separator: z.string().default('\n\n')
  ```
- [x] 핸들러 로직 동기화

## 테스트 시나리오

### 정상 케이스 1: Append 모드 기본 동작
- **Given**: windowId 42 창에 `"# 보고서\n항목 1"` 내용이 있음
- **When**: `update_markdown { windowId: 42, content: "항목 2", appendMode: true }` 호출
- **Then**: 창에 `"# 보고서\n항목 1\n\n항목 2"` 렌더링됨, `meta.lastRenderedContent` 갱신

### 정상 케이스 2: 커스텀 separator
- **Given**: 창에 `"로그 1"` 내용
- **When**: `update_markdown { windowId: X, content: "로그 2", appendMode: true, separator: "\n---\n" }` 호출
- **Then**: 창에 `"로그 1\n---\n로그 2"` 렌더링됨

### 정상 케이스 3: 첫 번째 append (lastRenderedContent 없음)
- **Given**: 새로 열린 창, lastRenderedContent 없음
- **When**: `update_markdown { windowId: X, content: "첫 내용", appendMode: true }` 호출
- **Then**: 창에 `"첫 내용"` 렌더링됨 (빈 문자열 + separator + content → trim 처리)

### 예외 케이스 1: filePath 창에 append 시도
- **Given**: filePath 기반으로 열린 창(windowId: 43)
- **When**: `update_markdown { windowId: 43, content: "추가", appendMode: true }` 호출
- **Then**: `isError: true`, `"appendMode is not supported for file-based windows."` 반환

### 예외 케이스 2: 누적 크기 10MB 초과
- **Given**: 창의 lastRenderedContent가 9.9MB
- **When**: 0.2MB 내용으로 append 시도 (합계 > 10MB)
- **Then**: `isError: true`, `"Accumulated content exceeds 10MB limit."` 반환, 기존 콘텐츠 보존

### 예외 케이스 3: appendMode + filePath 동시 지정
- **Given**: `update_markdown { windowId: X, filePath: "/path/to/file.md", appendMode: true }`
- **Then**: `isError: true` (filePath 창 체크에서 또는 별도 검증)

### 경계값: appendMode: true + content 없음
- **Given**: `update_markdown { windowId: X, appendMode: true }` (content 없음)
- **Then**: isError 반환, `"content is required for appendMode."` 메시지

## 로그 스트리밍 시나리오 (E2E)

```
# AI 에이전트가 10단계 작업을 실시간 보고하는 시나리오
1. open_markdown { windowName: "progress", content: "# 작업 진행\n" }
2. update_markdown { windowId: X, content: "1단계 완료", appendMode: true }
3. update_markdown { windowId: X, content: "2단계 완료", appendMode: true }
...
10. update_markdown { windowId: X, content: "10단계 완료", appendMode: true }

최종 창 내용:
# 작업 진행

1단계 완료

2단계 완료
...

10단계 완료
```

## 회귀테스트 실행 조건

- [x] Phase 1~4 기능 정상 동작
- [x] `appendMode: false` (기본) 시 기존 전체 교체 동작 유지
- [x] `update_markdown` filePath 기반 창 (filePath 제공) 기존 동작 유지
- [x] content 기반 창에서 `appendMode: false` 로 전체 교체 시 `lastRenderedContent` 갱신됨
