# Phase 7: API 및 SSE 스트리밍

## 1. 목표 및 범위

### 1.1 목표
- SSE 기반 실시간 응답 스트리밍
- 워크플로우 진행 상황 실시간 표시
- 챗봇 API 엔드포인트 구현
- RESTful API 설계 원칙 준수

### 1.2 요구사항 매핑
| 요구사항 ID | 설명 | 수용 기준 |
|-------------|------|----------|
| FR-CB-012 | 실시간 진행 상황 표시 | 워크플로우 단계별 상태 SSE 전송 |
| FR-CB-013 | 토큰 단위 스트리밍 | 생성 중인 답변 실시간 표시 |

### 1.3 선행 조건
- **Phase 1~6 완료**: 전체 워크플로우 구현

### 1.4 아키텍처 참조
- [00-1.architecture.md](./00-1.architecture.md) 섹션 5 (데이터 모델 - SSE 이벤트)
- [00-2.tech-decisions.md](./00-2.tech-decisions.md) ADR-006 (SSE)

---

## 2. API 설계 명세

### 2.1 엔드포인트 목록

| Method | Endpoint | 설명 | 인증 | 응답 형식 |
|--------|----------|------|------|----------|
| POST | `/api/chatbot/chat` | 챗봇 대화 요청 (SSE 스트림) | 불필요 | `text/event-stream` |
| GET | `/api/chatbot/status` | 챗봇 상태 조회 | 불필요 | `application/json` |
| GET | `/api/chatbot/history/:threadId` | 대화 히스토리 조회 | 불필요 | `application/json` |
| DELETE | `/api/chatbot/history/:threadId` | 대화 히스토리 삭제 | 필요 (X-API-Key) | `application/json` |

### 2.2 요청/응답 스키마

#### POST /api/chatbot/chat

**Request Body:**
```json
{
  "message": "string (required, 1-4000 characters)",
  "threadId": "string (optional, UUID format)",
  "thinkingMode": "boolean (optional, default: false)"
}
```

**Response (SSE Events):**
```
event: step
data: {"step": "classifyQuery", "message": "Analyzing your question..."}

event: retrieval
data: {"count": 20, "topScore": 0.89, "sources": ["doc1.md", "doc2.md"]}

event: token
data: {"content": "Hello"}

event: done
data: {"threadId": "abc-123", "totalTokens": 150, "duration": 2500}

event: error
data: {"code": "RATE_LIMITED", "message": "Too many requests", "retryAfter": 60}
```

#### GET /api/chatbot/status

**Response:**
```json
{
  "vectorStore": {
    "totalDocs": 50,
    "totalChunks": 250,
    "lastUpdated": "2025-01-08T10:00:00Z"
  },
  "llm": {
    "type": "openai",
    "model": "gpt-4o",
    "status": "connected"
  },
  "embedding": {
    "type": "openai",
    "model": "text-embedding-3-small",
    "status": "connected"
  }
}
```

#### GET /api/chatbot/history/:threadId

**Response:**
```json
{
  "threadId": "abc-123",
  "messages": [
    {"role": "human", "content": "Hello", "timestamp": "2025-01-08T10:00:00Z"},
    {"role": "ai", "content": "Hi there!", "timestamp": "2025-01-08T10:00:02Z"}
  ],
  "summary": "User greeted the assistant"
}
```

### 2.3 에러 코드 정의

| HTTP Status | Error Code | 설명 | 복구 가능 |
|-------------|------------|------|----------|
| 400 | `INVALID_MESSAGE` | 메시지가 비어있거나 너무 긴 경우 | Yes |
| 400 | `INVALID_THREAD_ID` | threadId 형식이 잘못된 경우 | Yes |
| 404 | `THREAD_NOT_FOUND` | 요청한 threadId가 존재하지 않음 | No |
| 429 | `RATE_LIMITED` | 요청 횟수 초과 (10회/분/세션) | Yes |
| 500 | `LLM_ERROR` | LLM API 호출 실패 | Retry |
| 500 | `EMBEDDING_ERROR` | 임베딩 API 호출 실패 | Retry |
| 503 | `SERVICE_UNAVAILABLE` | 챗봇 서비스 초기화 안됨 | Retry |

### 2.4 Rate Limiting 설계

```javascript
// 세션별 Rate Limiting 구현
const rateLimitStore = new Map(); // threadId -> { count, resetTime }

function checkRateLimit(threadId) {
  const now = Date.now();
  const windowMs = 60000; // 1분 윈도우
  const maxRequests = 10; // 최대 10회

  let entry = rateLimitStore.get(threadId);
  if (!entry || now > entry.resetTime) {
    entry = { count: 0, resetTime: now + windowMs };
    rateLimitStore.set(threadId, entry);
  }

  if (entry.count >= maxRequests) {
    const retryAfter = Math.ceil((entry.resetTime - now) / 1000);
    return { allowed: false, retryAfter };
  }

  entry.count++;
  return { allowed: true, remaining: maxRequests - entry.count };
}
```

**Rate Limit 응답 헤더:**
```
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 5
X-RateLimit-Reset: 1704712800
```

---

## 3. 구현 항목 체크리스트

### 3.1 SSE 미들웨어
- [ ] `src/middleware/sse.js` 생성
  - [ ] SSE 헤더 설정
  - [ ] sendEvent() 헬퍼 함수
  - [ ] 연결 종료 처리

### 3.2 챗봇 컨트롤러
- [ ] `src/controllers/chatbot-controller.js` 생성
  - [ ] POST /api/chatbot/chat - SSE 스트림 응답
  - [ ] GET /api/chatbot/history/:threadId - 히스토리 조회
  - [ ] DELETE /api/chatbot/history/:threadId - 히스토리 삭제
  - [ ] GET /api/chatbot/status - 상태 조회

### 3.3 챗봇 서비스
- [ ] `src/services/chatbot/index.js` 생성
  - [ ] ChatbotService 클래스
  - [ ] initialize() - 초기화
  - [ ] chat() - AsyncGenerator로 SSE 이벤트 생성
  - [ ] getHistory() - 히스토리 조회
  - [ ] clearHistory() - 히스토리 삭제
  - [ ] getStatus() - 상태 조회

### 3.4 라우트 정의
- [ ] `src/routes/chatbot.js` 생성
  - [ ] 라우트 등록

### 3.5 앱 통합
- [ ] `src/app.js` 수정
  - [ ] ChatbotService 초기화
  - [ ] 라우트 마운트

---

## 4. 상세 구현 가이드

### 4.1 SSE 미들웨어

```javascript
// src/middleware/sse.js

/**
 * SSE 응답 설정 미들웨어
 */
export function setupSSE(req, res, next) {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no'); // nginx 버퍼링 비활성화

  /**
   * SSE 이벤트 전송
   * @param {string} eventType - 이벤트 타입
   * @param {Object} data - 데이터
   */
  res.sendEvent = (eventType, data) => {
    res.write(`event: ${eventType}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  // 연결 종료 처리
  req.on('close', () => {
    res.end();
  });

  next();
}
```

### 4.2 챗봇 서비스

```javascript
// src/services/chatbot/index.js

import { createLLM } from './llm-factory.js';
import { createEmbeddings } from './embedding-factory.js';
import { VectorStoreManager } from './vector-store.js';
import { DocWatcher } from './doc-watcher.js';
import { loadMarkdownWithFrontmatter } from './doc-loader.js';
import { createChatbotGraph } from './workflow/graph.js';
import { HumanMessage } from "@langchain/core/messages";

export class ChatbotService {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    this.llm = null;
    this.embeddings = null;
    this.vectorStore = null;
    this.docWatcher = null;
    this.graph = null;
  }

  async initialize() {
    const chatbotConfig = this.config.chatbot;

    // LLM & Embeddings 생성
    this.llm = createLLM(chatbotConfig.llm);
    this.embeddings = createEmbeddings(chatbotConfig.embedding);

    // VectorStore 초기화
    this.vectorStore = new VectorStoreManager(
      this.embeddings,
      chatbotConfig.rag,
      { logger: this.logger }
    );
    await this.vectorStore.initialize();

    // 문서 감시 시작
    this.docWatcher = new DocWatcher(this.config.docsRoot, {
      logger: this.logger,
    });

    this.docWatcher.on('add', (path) => this._handleDocChange(path));
    this.docWatcher.on('change', (path) => this._handleDocChange(path));
    this.docWatcher.on('remove', (path) => this.vectorStore.removeDocument(path));
    this.docWatcher.start();

    // 그래프 생성
    this.graph = createChatbotGraph(
      this.config,
      this.llm,
      this.vectorStore.getRetriever()
    );

    this.logger.info('ChatbotService initialized');
  }

  async _handleDocChange(filePath) {
    try {
      const { pageContent, metadata } = await loadMarkdownWithFrontmatter(filePath);
      await this.vectorStore.addDocument(filePath, pageContent, metadata);
    } catch (error) {
      this.logger.error(`Failed to process document: ${filePath}`, error);
    }
  }

  /**
   * 챗봇 대화 (SSE 스트림 반환)
   */
  async *chat(message, threadId, options = {}) {
    const { thinkingMode = false } = options;

    try {
      // 스트리밍 실행
      for await (const [streamMode, chunk] of await this.graph.stream(
        {
          messages: [new HumanMessage(message)],
          thinkingMode,
        },
        {
          configurable: { thread_id: threadId },
          streamMode: ["updates", "messages"],
        }
      )) {
        // 노드 업데이트 (워크플로우 진행 상황)
        if (streamMode === "updates") {
          for (const [nodeName, nodeOutput] of Object.entries(chunk)) {
            yield {
              type: 'step',
              data: {
                step: nodeOutput.currentStep || nodeName,
                message: this._getStepMessage(nodeName),
              },
            };

            // 검색 결과 정보
            if (nodeOutput.retrievedDocs) {
              yield {
                type: 'retrieval',
                data: {
                  count: nodeOutput.retrievedDocs.length,
                  sources: nodeOutput.retrievedDocs.slice(0, 5).map(d => d.metadata.source),
                },
              };
            }
          }
        }

        // 토큰 스트리밍
        if (streamMode === "messages") {
          const [message, metadata] = chunk;
          if (message.content) {
            yield {
              type: 'token',
              data: { content: message.content },
            };
          }
        }
      }

      // 완료
      yield {
        type: 'done',
        data: { threadId },
      };

    } catch (error) {
      this.logger.error('Chat error:', error);
      yield {
        type: 'error',
        data: {
          message: error.message,
          code: error.code || 'UNKNOWN_ERROR',
        },
      };
    }
  }

  _getStepMessage(nodeName) {
    const messages = {
      classifyQuery: 'Analyzing your question...',
      retrieveDocs: 'Searching relevant documents...',
      gradeDocuments: 'Evaluating document relevance...',
      rewriteQuery: 'Refining search query...',
      generateAnswer: 'Generating response...',
      summarizeHistory: 'Summarizing conversation...',
      analyzeQuestion: 'Analyzing question complexity...',
      planStrategy: 'Planning response strategy...',
      executeSteps: 'Executing reasoning steps...',
    };
    return messages[nodeName] || `Processing ${nodeName}...`;
  }

  getStatus() {
    const stats = this.vectorStore.getStats();
    return {
      vectorStore: stats,
      llm: {
        type: this.config.chatbot.llm.type,
        model: this.config.chatbot.llm.model,
        status: 'connected',
      },
      embedding: {
        type: this.config.chatbot.embedding.type,
        model: this.config.chatbot.embedding.model,
        status: 'connected',
      },
    };
  }

  async close() {
    if (this.docWatcher) {
      await this.docWatcher.close();
    }
  }
}
```

### 4.3 챗봇 컨트롤러

```javascript
// src/controllers/chatbot-controller.js

import crypto from 'crypto';

/**
 * POST /api/chatbot/chat
 * SSE 스트림 응답
 */
export async function handleChat(req, res) {
  const { message, threadId, thinkingMode } = req.body;
  const chatbotService = req.app.locals.chatbotService;

  if (!message) {
    return res.status(400).json({ error: 'Message is required' });
  }

  const actualThreadId = threadId || crypto.randomUUID();

  try {
    for await (const event of chatbotService.chat(message, actualThreadId, { thinkingMode })) {
      res.sendEvent(event.type, event.data);
    }
  } catch (error) {
    res.sendEvent('error', { message: error.message });
  } finally {
    res.end();
  }
}

/**
 * GET /api/chatbot/status
 */
export function handleStatus(req, res) {
  const chatbotService = req.app.locals.chatbotService;
  const status = chatbotService.getStatus();
  res.json(status);
}
```

### 4.4 라우트 정의

```javascript
// src/routes/chatbot.js

import { Router } from 'express';
import { setupSSE } from '../middleware/sse.js';
import { handleChat, handleStatus } from '../controllers/chatbot-controller.js';

const router = Router();

// SSE 스트림 엔드포인트
router.post('/chat', setupSSE, handleChat);

// 상태 조회
router.get('/status', handleStatus);

export default router;
```

### 4.5 클라이언트 SSE 처리

```javascript
// public/js/chatbot.js - SSE 클라이언트 처리 예시

/**
 * SSE 스트림 응답 처리
 * 주의: POST 요청에서는 EventSource를 사용할 수 없으므로
 * fetch API + ReadableStream을 사용합니다.
 */
async function streamChatResponse(message, threadId, thinkingMode) {
  const response = await fetch('/api/chatbot/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message, threadId, thinkingMode }),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let currentEventType = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });

    // SSE 이벤트 파싱
    const lines = buffer.split('\n');
    buffer = lines.pop() || ''; // 마지막 불완전한 줄은 버퍼에 유지

    for (const line of lines) {
      if (line.startsWith('event: ')) {
        currentEventType = line.slice(7).trim();
      } else if (line.startsWith('data: ')) {
        const data = JSON.parse(line.slice(6));
        handleSSEEvent(currentEventType, data);
      }
    }
  }
}

/**
 * SSE 이벤트 타입별 처리
 */
function handleSSEEvent(eventType, data) {
  switch (eventType) {
    case 'step':
      updateWorkflowIndicator(data.message);
      break;
    case 'retrieval':
      showRetrievalInfo(data.count, data.sources);
      break;
    case 'token':
      appendToken(data.content);
      break;
    case 'done':
      completeResponse(data.threadId);
      break;
    case 'error':
      showError(data.message);
      break;
  }
}
```

### 4.6 앱 통합

```javascript
// src/app.js (수정)

import { ChatbotService } from './services/chatbot/index.js';
import chatbotRoutes from './routes/chatbot.js';

// ChatbotService 초기화
if (config.chatbot) {
  const chatbotService = new ChatbotService(config, logger);
  await chatbotService.initialize();
  app.locals.chatbotService = chatbotService;

  // 라우트 마운트
  app.use('/api/chatbot', chatbotRoutes);

  logger.info('Chatbot service initialized');
}
```

---

## 5. 테스트 섹션

### 5.1 테스트 시나리오

#### TC-CB-012: 워크플로우 진행 상황 SSE
```gherkin
Given 챗봇 서비스가 초기화됨
When POST /api/chatbot/chat 요청을 보냄
Then SSE 이벤트가 순차적으로 수신됨:
  | event: step | "Analyzing your question..." |
  | event: step | "Searching relevant documents..." |
  | event: retrieval | count: 20, sources: [...] |
  | event: step | "Generating response..." |
  | event: token | ... |
  | event: done | threadId |
```

#### TC-CB-013: 토큰 스트리밍
```gherkin
Given 답변 생성 중
When LLM이 토큰을 생성함
Then 각 토큰이 개별 SSE 이벤트로 전송됨
  And TTFB ≤ 2초
```

---

## 6. 예상 산출물

```
src/
├── middleware/
│   └── sse.js                    # SSE 미들웨어
├── controllers/
│   └── chatbot-controller.js     # API 컨트롤러
├── routes/
│   └── chatbot.js                # 라우트
└── services/
    └── chatbot/
        └── index.js              # ChatbotService
```

---

## 7. 완료 기준

- [ ] SSE 스트림 정상 동작
- [ ] 워크플로우 단계별 이벤트 전송
- [ ] 토큰 단위 스트리밍 동작
- [ ] TTFB ≤ 2초 확인
- [ ] 검증 문서 작성 완료
