# Phase 2: 문서 처리 파이프라인

## 1. 목표 및 범위

### 1.1 목표
- docsRoot 디렉토리의 Markdown 파일 감시 및 변경 감지
- Frontmatter 메타데이터 파싱 (name, description 등)
- 문서 청킹 및 벡터 스토어 관리

### 1.2 요구사항 매핑
| 요구사항 ID | 설명 | 수용 기준 |
|-------------|------|----------|
| FR-CB-003 | Markdown 문서 자동 임베딩 | docsRoot 내 .md 파일 100% 벡터화 완료 |
| FR-CB-004 | Frontmatter 메타데이터 추출 | name, description 필드 정상 파싱 |
| FR-CB-005 | 실시간 문서 변경 감지 | 파일 추가/수정/삭제 5초 이내 반영 |

### 1.3 선행 조건
- **Phase 1 완료**: LLM Factory, Embedding Factory 구현됨

### 1.4 아키텍처 참조
- [00-1.architecture.md](./00-1.architecture.md) 섹션 2.1 (Document Pipeline), 3.3 (클래스 다이어그램)
- [00-2.tech-decisions.md](./00-2.tech-decisions.md) ADR-003, ADR-004, ADR-007

---

## 2. 구현 항목 체크리스트

### 2.1 DocWatcher 구현
- [ ] `src/services/chatbot/doc-watcher.js` 생성
  - [ ] EventEmitter 상속
  - [ ] chokidar 기반 파일 감시
  - [ ] `**/*.md` 패턴 감시
  - [ ] debounce 처리 (1초)
  - [ ] `awaitWriteFinish` 옵션 적용
  - [ ] 이벤트: `add`, `change`, `remove`
  - [ ] `close()` 메서드

### 2.2 DocLoader 구현
- [ ] `src/services/chatbot/doc-loader.js` 생성
  - [ ] `loadMarkdownWithFrontmatter(filePath)` 함수
  - [ ] YAML Frontmatter 파싱 (`---` ... `---`)
  - [ ] metadata 객체 생성 (filePath, source, name, description 등)
  - [ ] pageContent (Frontmatter 제외 본문) 반환

### 2.3 VectorStoreManager 구현
- [ ] `src/services/chatbot/vector-store.js` 생성
  - [ ] MemoryVectorStore 래퍼 클래스
  - [ ] RecursiveCharacterTextSplitter (Markdown 모드)
  - [ ] `initialize()` - 초기화
  - [ ] `addDocument(filePath, content, metadata)` - 문서 추가
  - [ ] `removeDocument(filePath)` - 문서 제거
  - [ ] `getRetriever(k)` - Retriever 반환
  - [ ] `getStats()` - 통계 반환
  - [ ] 해시 기반 변경 감지 (중복 임베딩 방지)

### 2.4 의존성 설치
- [ ] package.json 업데이트
  - [ ] @langchain/textsplitters ^0.1.x
  - [ ] @langchain/classic ^0.0.x

---

## 3. 상세 구현 가이드

### 3.1 DocWatcher 구현

```javascript
// src/services/chatbot/doc-watcher.js

import chokidar from 'chokidar';
import { EventEmitter } from 'events';
import path from 'path';

/**
 * Markdown 문서 파일 변경 감시
 * @extends EventEmitter
 * @fires DocWatcher#add - 파일 추가 시
 * @fires DocWatcher#change - 파일 변경 시
 * @fires DocWatcher#remove - 파일 삭제 시
 */
export class DocWatcher extends EventEmitter {
  /**
   * @param {string} docsRoot - 문서 루트 디렉토리
   * @param {Object} options - 옵션
   * @param {number} options.debounceMs - 디바운스 시간 (기본: 1000ms)
   * @param {Object} options.logger - 로거 인스턴스
   */
  constructor(docsRoot, options = {}) {
    super();
    this.docsRoot = docsRoot;
    this.debounceMs = options.debounceMs || 1000;
    this.logger = options.logger;
    this.pendingChanges = new Map();
    this.watcher = null;
  }

  /**
   * 파일 감시 시작
   */
  start() {
    const pattern = path.join(this.docsRoot, '**/*.md').replace(/\\/g, '/');

    this.watcher = chokidar.watch(pattern, {
      persistent: true,
      ignoreInitial: false,
      awaitWriteFinish: {
        stabilityThreshold: 500,
        pollInterval: 100,
      },
    });

    this.watcher
      .on('add', (filePath) => this._debouncedEmit('add', filePath))
      .on('change', (filePath) => this._debouncedEmit('change', filePath))
      .on('unlink', (filePath) => {
        // 삭제는 즉시 처리 (디바운스 불필요)
        this._clearPending(filePath);
        this.emit('remove', filePath);
      })
      .on('error', (error) => {
        this.logger?.error('DocWatcher error:', error);
        this.emit('error', error);
      });

    this.logger?.info(`DocWatcher started: ${pattern}`);
  }

  /**
   * 디바운스된 이벤트 발생
   * @private
   */
  _debouncedEmit(event, filePath) {
    this._clearPending(filePath);

    const timeout = setTimeout(() => {
      this.pendingChanges.delete(filePath);
      this.emit(event, filePath);
    }, this.debounceMs);

    this.pendingChanges.set(filePath, timeout);
  }

  /**
   * 대기 중인 이벤트 취소
   * @private
   */
  _clearPending(filePath) {
    if (this.pendingChanges.has(filePath)) {
      clearTimeout(this.pendingChanges.get(filePath));
      this.pendingChanges.delete(filePath);
    }
  }

  /**
   * 파일 감시 중지
   */
  async close() {
    if (this.watcher) {
      await this.watcher.close();
      this.watcher = null;
    }

    // 대기 중인 모든 타임아웃 취소
    for (const timeout of this.pendingChanges.values()) {
      clearTimeout(timeout);
    }
    this.pendingChanges.clear();

    this.logger?.info('DocWatcher closed');
  }
}
```

### 3.2 DocLoader 구현

```javascript
// src/services/chatbot/doc-loader.js

import fs from 'fs/promises';
import path from 'path';

/**
 * YAML Frontmatter 정규식
 * ---로 시작하고 ---로 끝나는 블록
 */
const FRONTMATTER_REGEX = /^---\r?\n([\s\S]*?)\r?\n---\r?\n/;

/**
 * Markdown 파일 로드 및 Frontmatter 파싱
 * @param {string} filePath - 파일 경로
 * @returns {Promise<{pageContent: string, metadata: Object}>}
 */
export async function loadMarkdownWithFrontmatter(filePath) {
  const content = await fs.readFile(filePath, 'utf-8');
  const { frontmatter, body } = parseFrontmatter(content);

  const metadata = {
    filePath,
    source: path.basename(filePath),
    ...frontmatter,
  };

  return {
    pageContent: body,
    metadata,
  };
}

/**
 * Frontmatter 파싱
 * @param {string} content - 파일 내용
 * @returns {{frontmatter: Object, body: string}}
 */
export function parseFrontmatter(content) {
  const match = content.match(FRONTMATTER_REGEX);

  if (!match) {
    return { frontmatter: {}, body: content };
  }

  const frontmatterStr = match[1];
  const body = content.slice(match[0].length);

  // 간단한 YAML 파싱 (key: value 형식)
  const frontmatter = {};
  const lines = frontmatterStr.split(/\r?\n/);

  for (const line of lines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const key = line.slice(0, colonIndex).trim();
      let value = line.slice(colonIndex + 1).trim();

      // 따옴표 제거
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }

      frontmatter[key] = value;
    }
  }

  return { frontmatter, body };
}
```

### 3.3 VectorStoreManager 구현

```javascript
// src/services/chatbot/vector-store.js

import { MemoryVectorStore } from "@langchain/classic/vectorstores/memory";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import crypto from 'crypto';

/**
 * 벡터 스토어 관리자
 */
export class VectorStoreManager {
  /**
   * @param {Embeddings} embeddings - Embedding 인스턴스
   * @param {Object} config - RAG 설정
   * @param {Object} options - 옵션
   * @param {Object} options.logger - 로거
   */
  constructor(embeddings, config, options = {}) {
    this.embeddings = embeddings;
    this.config = config;
    this.logger = options.logger;

    this.vectorStore = null;
    this.documentHashes = new Map();
    this.documentChunkIds = new Map(); // filePath -> chunkIds[]
    this.lastUpdated = null;

    this.splitter = RecursiveCharacterTextSplitter.fromLanguage("markdown", {
      chunkSize: config.chunkSize || 1000,
      chunkOverlap: config.chunkOverlap || 200,
    });
  }

  /**
   * 벡터 스토어 초기화
   */
  async initialize() {
    this.vectorStore = new MemoryVectorStore(this.embeddings);
    this.logger?.info('VectorStoreManager initialized');
  }

  /**
   * 문서 추가/업데이트
   * @param {string} filePath - 파일 경로
   * @param {string} content - 문서 내용
   * @param {Object} metadata - 메타데이터
   */
  async addDocument(filePath, content, metadata) {
    const hash = this._computeHash(content);

    // 변경 없으면 스킵
    if (this.documentHashes.get(filePath) === hash) {
      this.logger?.debug(`Skipping unchanged document: ${filePath}`);
      return;
    }

    // 기존 문서 제거
    await this.removeDocument(filePath);

    // 청킹
    const chunks = await this.splitter.createDocuments(
      [content],
      [{ ...metadata, filePath }]
    );

    // 각 청크에 고유 ID 부여
    const chunkIds = [];
    for (let i = 0; i < chunks.length; i++) {
      const chunkId = `${filePath}#${i}`;
      chunks[i].metadata.chunkId = chunkId;
      chunkIds.push(chunkId);
    }

    // 벡터 스토어에 추가
    await this.vectorStore.addDocuments(chunks);

    // 상태 업데이트
    this.documentHashes.set(filePath, hash);
    this.documentChunkIds.set(filePath, chunkIds);
    this.lastUpdated = new Date();

    this.logger?.info(`Added document: ${filePath} (${chunks.length} chunks)`);
  }

  /**
   * 문서 제거
   * @param {string} filePath - 파일 경로
   */
  async removeDocument(filePath) {
    // MemoryVectorStore는 직접 삭제를 지원하지 않음
    // 해시와 청크 ID만 제거 (재구축 시 제외됨)
    this.documentHashes.delete(filePath);
    this.documentChunkIds.delete(filePath);
    this.logger?.info(`Removed document tracking: ${filePath}`);

    // 참고: 실제 벡터 삭제는 전체 재구축 필요
    // 향후 개선: 필터링된 retriever 사용
  }

  /**
   * Retriever 반환
   * @param {number} k - 검색할 문서 수 (기본: 20)
   * @returns {VectorStoreRetriever}
   */
  getRetriever(k = 20) {
    const retrievalCount = this.config.retrievalCount || k;
    return this.vectorStore.asRetriever(retrievalCount);
  }

  /**
   * 통계 반환
   * @returns {{totalDocs: number, totalChunks: number, lastUpdated: Date|null}}
   */
  getStats() {
    let totalChunks = 0;
    for (const chunks of this.documentChunkIds.values()) {
      totalChunks += chunks.length;
    }

    return {
      totalDocs: this.documentHashes.size,
      totalChunks,
      lastUpdated: this.lastUpdated,
    };
  }

  /**
   * 해시 계산
   * @private
   */
  _computeHash(content) {
    return crypto
      .createHash('sha256')
      .update(content)
      .digest('base64')
      .slice(0, 32);
  }
}
```

---

## 4. 테스트 섹션

### 4.1 테스트 시나리오

#### TC-CB-003: Markdown 문서 청킹
```gherkin
Given 1000자 이상의 Markdown 문서가 있음
When VectorStoreManager.addDocument()를 호출하면
Then 문서가 청크로 분할됨
  And 각 청크가 벡터 스토어에 추가됨
  And 청크 수가 getStats()에 반영됨
```

#### TC-CB-004: Frontmatter 파싱
```gherkin
Given 다음 Frontmatter가 있는 문서:
  """
  ---
  name: API 가이드
  description: REST API 사용 방법
  ---
  # 본문
  """
When loadMarkdownWithFrontmatter()를 호출하면
Then metadata.name === "API 가이드"
  And metadata.description === "REST API 사용 방법"
  And pageContent에 Frontmatter가 포함되지 않음
```

#### TC-CB-005: 파일 변경 감지
```gherkin
Given DocWatcher가 docsRoot를 감시 중임
When .md 파일이 수정됨
Then 5초 이내에 'change' 이벤트가 발생함
  And 이벤트에 파일 경로가 포함됨
```

#### TC-CB-005-2: 파일 삭제 감지
```gherkin
Given DocWatcher가 docsRoot를 감시 중임
When .md 파일이 삭제됨
Then 즉시 'remove' 이벤트가 발생함
```

### 4.2 테스트 코드 작성 지침

```javascript
// test/chatbot/doc-loader.test.js

import { describe, it, expect } from 'vitest';
import { loadMarkdownWithFrontmatter, parseFrontmatter } from '../../src/services/chatbot/doc-loader.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('DocLoader', () => {
  describe('parseFrontmatter', () => {
    it('should parse YAML frontmatter', () => {
      const content = `---
name: Test Doc
description: A test document
---
# Heading
Body content`;

      const { frontmatter, body } = parseFrontmatter(content);

      expect(frontmatter.name).toBe('Test Doc');
      expect(frontmatter.description).toBe('A test document');
      expect(body.trim()).toBe('# Heading\nBody content');
    });

    it('should handle no frontmatter', () => {
      const content = '# Heading\nBody content';

      const { frontmatter, body } = parseFrontmatter(content);

      expect(frontmatter).toEqual({});
      expect(body).toBe(content);
    });

    it('should handle quoted values', () => {
      const content = `---
name: "Quoted Value"
other: 'Single Quoted'
---
Body`;

      const { frontmatter } = parseFrontmatter(content);

      expect(frontmatter.name).toBe('Quoted Value');
      expect(frontmatter.other).toBe('Single Quoted');
    });
  });

  describe('loadMarkdownWithFrontmatter', () => {
    it('should load file and parse frontmatter', async () => {
      // 임시 파일 생성
      const tmpDir = os.tmpdir();
      const tmpFile = path.join(tmpDir, 'test-doc.md');
      await fs.writeFile(tmpFile, `---
name: Test
---
# Content`);

      try {
        const result = await loadMarkdownWithFrontmatter(tmpFile);

        expect(result.metadata.name).toBe('Test');
        expect(result.metadata.filePath).toBe(tmpFile);
        expect(result.metadata.source).toBe('test-doc.md');
        expect(result.pageContent.trim()).toBe('# Content');
      } finally {
        await fs.unlink(tmpFile);
      }
    });
  });
});
```

### 4.3 회귀테스트 실행 조건

- DocWatcher, DocLoader, VectorStoreManager 코드 변경 시
- @langchain/textsplitters, @langchain/classic 버전 업그레이드 시
- chokidar 버전 업그레이드 시

---

## 5. 품질 기준

| 기준 | 목표 | 검증 방법 |
|------|------|----------|
| Plan-Code 정합성 | 100% | 체크리스트 대비 코드 리뷰 |
| 테스트 커버리지 | ≥ 80% | Jest/Vitest 커버리지 리포트 |
| 변경 감지 시간 | ≤ 5초 | 수동 테스트 |
| 임베딩 처리량 | ≥ 5 docs/sec | 벤치마크 |

---

## 6. 예상 산출물

### 6.1 생성 파일
```
src/
└── services/
    └── chatbot/
        ├── doc-watcher.js    # 파일 감시
        ├── doc-loader.js     # 문서 로드
        └── vector-store.js   # 벡터 스토어 관리

test/
└── chatbot/
    ├── doc-watcher.test.js
    ├── doc-loader.test.js
    └── vector-store.test.js
```

---

## 7. 완료 기준

- [ ] 모든 구현 항목 체크리스트 완료
- [ ] 모든 테스트 케이스 통과
- [ ] 코드 커버리지 80% 이상
- [ ] 파일 변경 감지 5초 이내 확인
- [ ] 검증 문서 작성 완료
