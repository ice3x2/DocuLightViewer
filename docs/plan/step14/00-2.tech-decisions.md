# Admin Mode 기술 결정 기록 (ADR)

| 항목 | 내용 |
|------|------|
| **문서 버전** | 1.0.0 |
| **작성일** | 2026-01-06 |
| **관련 스펙** | plan.step14.md |
| **상태** | 승인됨 |

---

## 1. 개요

이 문서는 Admin Mode 구현에서 내린 주요 기술 결정을 기록합니다. 각 결정에 대한 배경, 선택지, 근거, 결과를 문서화합니다.

---

## 2. 기술 결정 목록

### ADR-001: 세션 저장 방식

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

관리자 인증 후 세션을 유지해야 합니다. 세션 데이터를 어디에 저장할지 결정이 필요합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| **A. 메모리 (Map)** | 구현 간단, 의존성 없음, 빠른 접근 | 서버 재시작 시 세션 손실, 수평 확장 불가 |
| B. Redis | 서버 재시작 시 유지, 수평 확장 가능 | 외부 의존성 추가, 설정 복잡 |
| C. 파일 기반 | 의존성 없음, 재시작 후 유지 | I/O 오버헤드, 동시성 처리 복잡 |
| D. JWT (Stateless) | 서버 상태 불필요, 확장 용이 | 토큰 무효화 어려움, 토큰 크기 큼 |

#### 결정

**A. 메모리 기반 Map** 선택

#### 근거

1. DocLight는 단일 서버 운영을 전제로 함
2. 관리자 기능으로 동시 세션 수가 적음 (예상: 1-5개)
3. 서버 재시작 시 세션 손실은 수용 가능 (재로그인하면 됨)
4. 추가 의존성 없이 구현 가능
5. 추후 Redis 확장 가능한 인터페이스로 설계

#### 결과

- `session-service.js`에서 `Map<token, Session>` 사용
- 1분마다 만료 세션 정리 (메모리 누수 방지)
- 인터페이스 추상화로 추후 확장 가능

---

### ADR-002: 인증 토큰 전달 방식

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

세션 토큰을 클라이언트에서 서버로 전달하는 방식을 결정해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| **A. HttpOnly Cookie** | CSRF 외 XSS 방어, 자동 전송 | CORS 설정 필요, SameSite 설정 필요 |
| B. Authorization Header | 명시적 전송, CORS 친화적 | XSS에 취약 (localStorage), 매 요청 추가 필요 |
| **C. 둘 다 지원** | 유연성 | 구현 복잡도 증가 |

#### 결정

**C. 둘 다 지원** (Cookie 우선, Header 폴백)

#### 근거

1. Cookie: 웹 브라우저 사용 시 편리 (자동 전송)
2. Header: API 테스트, 외부 도구 연동 시 유용
3. 두 방식 모두 지원해도 구현 복잡도가 크게 증가하지 않음

#### 결과

```javascript
// admin-auth.js
const token = req.cookies.doclight_admin_session
           || req.headers.authorization?.replace('Bearer ', '');
```

---

### ADR-003: 다중 API 키 설정 스키마

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

복수의 API 키를 설정 파일에서 관리하면서 기존 단일 키 설정과 하위 호환성을 유지해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| A. apiKey 필드를 배열로 변경 | 단순 | 기존 설정 파일 마이그레이션 필요 |
| **B. apiKeys 필드 추가 (공존)** | 하위 호환, 점진적 마이그레이션 | 두 필드 관리 필요 |
| C. admin.apiKeys 하위 필드로 | 관리자 설정 분리 | 기존 apiKey와 혼동 가능 |

#### 결정

**B. apiKeys 필드 추가 (공존)**

#### 근거

1. 기존 `apiKey` 단일 값 설정 유지 → 기존 사용자 영향 없음
2. `apiKeys` 배열이 있으면 우선 사용, 없으면 `apiKey`를 기본 권한으로 변환
3. 점진적 마이그레이션 가능

#### 결과

```json5
{
  // 옵션 1: 기존 방식 (하위 호환)
  "apiKey": "single-key",

  // 옵션 2: 신규 방식 (다중 키)
  "apiKeys": [
    { "key": "...", "name": "...", "permissions": [...] }
  ]
}
```

```javascript
// config-loader.js
function normalizeApiKeys(config) {
  if (config.apiKey && !config.apiKeys) {
    config.apiKeys = [{
      key: config.apiKey,
      name: "Default Admin",
      permissions: ["read", "write", "delete"]
    }];
  }
  return config;
}
```

---

### ADR-004: 파일 트리 확장자 필터링

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

관리자 모드에서는 모든 파일을 표시해야 하지만, 일반 모드의 기존 동작(md 파일만)을 유지해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| A. 별도 API 엔드포인트 | 명확한 분리 | 코드 중복 |
| **B. 기존 tree-service에 옵션 추가** | 코드 재사용 | 서비스 복잡도 증가 |
| C. 클라이언트에서 필터링 | 서버 변경 최소화 | 불필요한 데이터 전송 |

#### 결정

**B. 기존 tree-service에 옵션 추가**

#### 근거

1. 트리 생성 로직을 중복하지 않음
2. `options.includeAllFiles` 플래그로 동작 제어
3. 기존 API는 영향 없음 (기본값 false)

#### 결과

```javascript
// tree-service.js
function getDirectoryTree(config, logger, userPath, options = {}) {
  const { includeAllFiles = false } = options;

  // includeAllFiles가 true면 .md 필터 스킵
  if (!includeAllFiles && !entry.name.endsWith('.md')) {
    continue;
  }
}
```

---

### ADR-005: 드래그앤드롭 구현 방식

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

파일/폴더를 드래그하여 다른 위치로 이동하는 기능을 구현해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| **A. HTML5 Drag and Drop API** | 네이티브, 추가 라이브러리 없음 | 브라우저 간 동작 차이 |
| B. 라이브러리 (SortableJS) | 일관된 동작, 풍부한 기능 | 추가 의존성 |
| C. 마우스 이벤트 직접 처리 | 완전한 제어 | 구현 복잡, 접근성 문제 |

#### 결정

**A. HTML5 Drag and Drop API**

#### 근거

1. 추가 의존성 없음 (DocLight 철학)
2. 대상 브라우저 (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+)에서 안정적 지원
3. 필요한 기능이 단순함 (파일 이동만, 정렬 없음)
4. 접근성 지원 (aria-* 속성 활용)

#### 결과

```javascript
// admin.js - 드래그앤드롭 이벤트
element.setAttribute('draggable', 'true');
element.addEventListener('dragstart', handleDragStart);
element.addEventListener('dragover', handleDragOver);
element.addEventListener('drop', handleDrop);
element.addEventListener('dragend', handleDragEnd);
```

---

### ADR-006: 컨텍스트 메뉴 구현 방식

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

파일/폴더 우클릭 시 컨텍스트 메뉴를 표시해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| **A. 커스텀 HTML 메뉴** | 완전한 스타일 제어, 크로스 브라우저 | 직접 구현 필요 |
| B. 네이티브 컨텍스트 메뉴 | 빠름, 접근성 좋음 | 스타일링 불가, 기능 제한 |
| C. 라이브러리 (ContextMenu.js) | 기능 풍부 | 추가 의존성 |

#### 결정

**A. 커스텀 HTML 메뉴**

#### 근거

1. UI 일관성 유지 (DocLight 디자인 시스템)
2. 조건부 메뉴 항목 (파일/폴더에 따라 다른 메뉴)
3. 아이콘, 구분선 등 자유로운 커스터마이징
4. 추가 의존성 없음

#### 결과

```javascript
// admin.js
function showContextMenu(x, y, targetPath, targetType) {
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  menu.style.left = `${x}px`;
  menu.style.top = `${y}px`;
  // ... 메뉴 항목 생성
  document.body.appendChild(menu);
}
```

---

### ADR-007: 편집기 구현 방식

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

마크다운 파일 편집을 위한 텍스트 편집기를 구현해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| **A. 기본 textarea** | 단순, 가벼움, 의존성 없음 | 줄번호, 하이라이팅 없음 |
| B. CodeMirror | 풍부한 기능, 문법 강조 | 큰 번들 크기 (~500KB) |
| C. Monaco Editor | VS Code급 기능 | 매우 큰 번들 (~5MB) |
| D. Ace Editor | 균형 잡힌 기능 | 의존성 추가 |

#### 결정

**A. 기본 textarea** (1차), 추후 확장 고려

#### 근거

1. MVP 우선: 기본 텍스트 편집으로 핵심 기능 구현
2. 번들 크기 최소화 (DocLight는 경량 도구)
3. 추후 CodeMirror 6 (모듈러) 도입 가능
4. 현재 요구사항: 저장/로드/편집만 필요

#### 결과

```html
<!-- admin.ejs -->
<textarea id="editor" class="file-editor"></textarea>
```

```css
/* admin.css */
.file-editor {
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 14px;
  line-height: 1.5;
  tab-size: 2;
  resize: none;
}
```

---

### ADR-008: 동시 편집 충돌 처리

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

두 사용자가 동시에 같은 파일을 편집할 때 충돌을 처리해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| A. 파일 잠금 (비관적) | 충돌 원천 방지 | 구현 복잡, 데드락 위험 |
| **B. 버전 비교 (낙관적)** | 구현 간단, 대부분 케이스 처리 | 충돌 시 사용자 개입 필요 |
| C. OT/CRDT (실시간) | 동시 편집 지원 | 구현 매우 복잡 |
| D. 무시 (덮어쓰기) | 구현 없음 | 데이터 손실 위험 |

#### 결정

**B. 버전 비교 (낙관적 락)**

#### 근거

1. 실시간 협업은 제외 범위 (plan.step14.md 1.2.2)
2. 관리자 동시 접속이 적은 환경
3. modifiedAt 비교로 간단히 구현 가능
4. 충돌 시 사용자에게 선택권 제공

#### 결과

```javascript
// 저장 요청 시
{
  path: "/doc.md",
  content: "...",
  originalModifiedAt: "2026-01-06T10:00:00Z"  // 로드 시점
}

// 서버에서 비교
if (file.modifiedAt > request.originalModifiedAt) {
  return { error: { code: 'CONFLICT', serverModifiedAt: file.modifiedAt } };
}
```

---

### ADR-009: URL 라우팅 전략

| 항목 | 내용 |
|------|------|
| **상태** | 승인됨 |
| **일자** | 2026-01-06 |
| **결정자** | Claude Code |

#### 컨텍스트

관리자 모드의 URL 구조를 설계해야 합니다.

#### 선택지

| 옵션 | 장점 | 단점 |
|------|------|------|
| A. 쿼리 파라미터 (?admin=true) | 기존 URL 유지 | 북마크/공유 시 보안 위험 |
| **B. 별도 경로 (/admin/*)** | 명확한 분리, 인증 미들웨어 적용 용이 | URL 구조 변경 |
| C. 서브도메인 (admin.xxx) | 완전 분리 | DNS 설정 필요 |

#### 결정

**B. 별도 경로 (/admin/*)**

#### 근거

1. REQ-URL-001, 002 요구사항 충족 (plan.step14.md)
2. Express 미들웨어로 인증 체크 용이
3. 일반 모드와 관리자 모드 완전 분리
4. 사용자 요구사항: "/admin 으로 시작"

#### 결과

```javascript
// app.js
app.use('/admin', adminRouter);
app.use('/api/admin', adminApiRouter);

// URL 예시
// /admin            → 관리자 모드 진입 (인증 모달)
// /admin/guide/intro → 관리자 모드에서 파일 보기
// /api/admin/tree   → 관리자 API
```

---

## 3. 외부 라이브러리 목록

### 3.1 신규 의존성

| 패키지 | 용도 | 필수 여부 | 비고 |
|--------|------|----------|------|
| `cookie-parser` | 쿠키 파싱 | 필수 | 세션 쿠키 처리 |

### 3.2 기존 의존성 활용

| 패키지 | Admin Mode 활용 |
|--------|----------------|
| `crypto` (내장) | 세션 토큰 생성 |
| `fs/promises` | 파일 I/O |
| `path` | 경로 처리 |
| `async-lock` | 동시성 제어 (삭제/이동) |

### 3.3 클라이언트 라이브러리

| 라이브러리 | 용도 | 신규/기존 |
|-----------|------|----------|
| `marked.js` | 마크다운 미리보기 | 기존 |
| `highlight.js` | 코드 하이라이팅 | 기존 |
| `mermaid.js` | 다이어그램 | 기존 |
| `dompurify.js` | XSS 방지 | 기존 |

---

## 4. Node.js 호환성 확인

### 4.1 사용 기능

| 기능 | Node.js 버전 | 비고 |
|------|-------------|------|
| `crypto.randomBytes` | 0.5.8+ | 세션 토큰 |
| `fs/promises` | 14.0+ | 파일 I/O |
| `Map` | 0.12+ | 세션 저장소 |
| `Set` | 0.12+ | 확장된 경로 |
| `async/await` | 7.6+ | 비동기 처리 |
| `?.` (옵셔널 체이닝) | 14.0+ | 안전한 접근 |
| `??` (널 병합) | 14.0+ | 기본값 처리 |

### 4.2 최소 요구 버전

- **Node.js 18+** (기존 프로젝트 요구사항 유지)
- 모든 사용 기능이 Node.js 18에서 지원됨

---

## 5. 보안 고려사항

### 5.1 세션 토큰

- **길이**: 32바이트 (256비트) → 64자 hex 문자열
- **생성**: `crypto.randomBytes(32)` (CSPRNG)
- **저장**: 서버 메모리만 (클라이언트에 토큰만 전달)
- **만료**: 설정 가능 (기본 1시간)

### 5.2 쿠키 설정

```javascript
res.cookie('doclight_admin_session', token, {
  httpOnly: true,      // JavaScript 접근 불가
  secure: config.ssl?.enabled || false,  // HTTPS만
  sameSite: 'strict',  // CSRF 방지
  maxAge: config.admin.sessionTimeout
});
```

### 5.3 입력 검증

| 입력 | 검증 방법 |
|------|----------|
| API Key | 정확한 문자열 매칭 |
| 파일 경로 | path-validator.js |
| 파일 이름 | 특수문자 제한 (`<>:"|?*`) |
| 파일 내용 | 크기 제한 (maxEditableSize) |

---

## 6. 성능 고려사항

### 6.1 세션 조회

- Map.get(): O(1) 시간 복잡도
- 메모리 사용: 세션당 ~200바이트
- 예상 최대 세션: 100개 → ~20KB

### 6.2 트리 생성

- 기존 tree-service 재사용
- includeAllFiles 옵션이 필터링 스킵 시 약간 빠름
- 캐싱은 기존 cache-manager 활용 가능

### 6.3 파일 I/O

- 기존 file-service 재사용
- async-lock으로 동시 쓰기 방지
- 대용량 파일 편집 제한 (maxEditableSize)

---

*기술 결정 기록 문서 끝*
