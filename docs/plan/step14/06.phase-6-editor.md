# Phase 6: 편집 기능

| 항목 | 내용 |
|------|------|
| **Phase** | 6 |
| **예상 시간** | 12시간 |
| **선행 조건** | Phase 5 완료 |
| **관련 요구사항** | REQ-EDIT-001~006 |

---

## 1. 목표 및 범위

### 1.1 목표

- 마크다운 파일 인라인 편집기
- 저장 기능 (Ctrl+S)
- 미리보기/편집 모드 전환
- Dirty 상태 관리 및 미저장 경고

### 1.2 범위

**포함:**
- EditorModule (편집기 핵심 로직)
- 편집 UI (툴바, 에디터, 상태 표시)
- UnsavedChangesModal
- 키보드 단축키

**제외:**
- 고급 편집 기능 (자동완성, 문법 강조)
- 실시간 협업

---

## 2. 아키텍처 참조

> 참조: [00-1.architecture.md](00-1.architecture.md) - 3.3.3 편집 모드

### 2.1 관련 컴포넌트

```
public/js/admin.js   ← EditorModule 추가
public/css/admin.css ← 편집기 스타일 추가
```

### 2.2 상태 흐름

```
파일 선택 → 원본 로드 → 편집 모드 → 수정 → isDirty=true → 저장 → isDirty=false
                                          ↓
                                    다른 파일 선택 → 미저장 경고
```

---

## 3. 구현 항목 체크리스트

### 3.1 EditorModule

- [ ] **TASK-601**: openEditor(path)
  - 파일 내용 로드
  - 편집 UI 표시
  - originalContent 저장

- [ ] **TASK-602**: closeEditor()
  - isDirty 확인 → 경고 모달
  - 편집 UI 숨김

- [ ] **TASK-603**: setEditMode(mode)
  - 'edit' | 'preview' 모드 전환
  - edit: textarea 표시
  - preview: 렌더링된 HTML 표시

- [ ] **TASK-604**: handleInput()
  - currentContent 업데이트
  - isDirty 계산 (originalContent !== currentContent)
  - UI 상태 업데이트

- [ ] **TASK-605**: save()
  - API 호출 (PUT /api/admin/content)
  - 충돌 처리
  - originalContent 갱신
  - isDirty = false

- [ ] **TASK-606**: discardChanges()
  - currentContent = originalContent
  - isDirty = false
  - textarea 내용 복원

### 3.2 편집 UI

- [ ] **TASK-607**: 편집기 마크업 추가
  ```html
  <div id="editor-container">
    <div class="editor-toolbar">
      <span class="editor-path"></span>
      <span class="dirty-indicator"></span>
      <div class="editor-buttons">
        <button class="mode-preview">Preview</button>
        <button class="mode-edit">Edit</button>
        <button class="btn-save">Save</button>
      </div>
    </div>
    <textarea id="editor-textarea"></textarea>
    <div id="editor-preview"></div>
  </div>
  ```

- [ ] **TASK-608**: Dirty 표시기
  - [●] 아이콘으로 미저장 상태 표시
  - 타이틀 바에도 반영

- [ ] **TASK-609**: 모드 토글 버튼
  - Preview/Edit 버튼
  - 활성 모드 하이라이트

### 3.3 UnsavedChangesModal

- [ ] **TASK-610**: 마크업 추가
  ```html
  <div id="unsaved-modal" class="modal">
    <div class="modal-content">
      <h3>⚠️ Unsaved Changes</h3>
      <p>You have unsaved changes in <span class="file-path"></span></p>
      <div class="modal-buttons">
        <button class="btn-cancel">Cancel</button>
        <button class="btn-discard">Discard</button>
        <button class="btn-save">Save</button>
      </div>
    </div>
  </div>
  ```

- [ ] **TASK-611**: showUnsavedModal(callback)
  - 모달 표시
  - 버튼 클릭 시 callback 호출
  - callback('cancel' | 'discard' | 'save')

- [ ] **TASK-612**: 버튼 처리
  - Cancel: 모달 닫기, 작업 취소
  - Discard: 변경 사항 버리기, 작업 진행
  - Save: 저장 후 작업 진행

### 3.4 충돌 처리

- [ ] **TASK-613**: ConflictModal 마크업
  ```html
  <div id="conflict-modal" class="modal">
    <div class="modal-content">
      <h3>⚠️ File Conflict</h3>
      <p>This file was modified by another user.</p>
      <p>Server version: <span class="server-time"></span></p>
      <div class="modal-buttons">
        <button class="btn-reload">Reload</button>
        <button class="btn-overwrite">Overwrite</button>
      </div>
    </div>
  </div>
  ```

- [ ] **TASK-614**: handleConflict(serverModifiedAt)
  - 모달 표시
  - Reload: 서버 버전으로 새로고침
  - Overwrite: 강제 저장 (originalModifiedAt 없이)

### 3.5 키보드 단축키

- [ ] **TASK-615**: Ctrl+S → 저장
- [ ] **TASK-616**: Ctrl+E → 편집 모드 토글
- [ ] **TASK-617**: Escape → 편집기 닫기 (확인 필요 시)

### 3.6 통합

- [ ] **TASK-618**: 파일 선택 시 편집기 상태 확인
  - isDirty면 UnsavedChangesModal 표시

- [ ] **TASK-619**: 로그아웃 시 편집기 상태 확인

- [ ] **TASK-620**: 브라우저 닫기 시 경고 (beforeunload)

---

## 4. 상세 구현 명세

### 4.1 EditorModule

```javascript
const EditorModule = {
  editingFile: null,  // { path, originalContent, modifiedAt }
  isDirty: false,
  currentMode: 'preview',  // 'edit' | 'preview'

  async openEditor(path) {
    // 기존 편집 중이면 확인
    if (this.isDirty) {
      const action = await this.showUnsavedPrompt();
      if (action === 'cancel') return;
      if (action === 'save') await this.save();
    }

    // 파일 로드
    const result = await AdminAPI.getContent(path);
    if (!result.success) {
      alert('Failed to load file: ' + result.error?.message);
      return;
    }

    this.editingFile = {
      path,
      originalContent: result.content,
      modifiedAt: result.modifiedAt
    };
    this.isDirty = false;

    // UI 표시
    this.showEditorUI(path, result.content);
    this.setMode('edit');
  },

  showEditorUI(path, content) {
    const container = document.getElementById('editor-container');
    const textarea = document.getElementById('editor-textarea');
    const pathEl = container.querySelector('.editor-path');

    container.style.display = 'flex';
    document.getElementById('file-viewer').style.display = 'none';
    document.getElementById('content-placeholder').style.display = 'none';

    pathEl.textContent = path;
    textarea.value = content;

    this.updateDirtyIndicator();
  },

  closeEditor() {
    if (this.isDirty) {
      // 비동기 처리 필요
      return;
    }

    this.editingFile = null;
    document.getElementById('editor-container').style.display = 'none';
  },

  setMode(mode) {
    this.currentMode = mode;
    const textarea = document.getElementById('editor-textarea');
    const preview = document.getElementById('editor-preview');
    const editBtn = document.querySelector('.mode-edit');
    const previewBtn = document.querySelector('.mode-preview');

    if (mode === 'edit') {
      textarea.style.display = 'block';
      preview.style.display = 'none';
      editBtn.classList.add('active');
      previewBtn.classList.remove('active');
    } else {
      textarea.style.display = 'none';
      preview.style.display = 'block';
      editBtn.classList.remove('active');
      previewBtn.classList.add('active');

      // 마크다운 렌더링
      const content = textarea.value;
      preview.innerHTML = DOMPurify.sanitize(marked.parse(content));
      preview.querySelectorAll('pre code').forEach(block => {
        hljs.highlightElement(block);
      });
    }
  },

  handleInput() {
    const textarea = document.getElementById('editor-textarea');
    const newIsDirty = textarea.value !== this.editingFile?.originalContent;

    if (newIsDirty !== this.isDirty) {
      this.isDirty = newIsDirty;
      this.updateDirtyIndicator();
    }
  },

  updateDirtyIndicator() {
    const indicator = document.querySelector('.dirty-indicator');
    const saveBtn = document.querySelector('.btn-save');

    if (this.isDirty) {
      indicator.textContent = '●';
      indicator.title = 'Unsaved changes';
      saveBtn.disabled = false;
    } else {
      indicator.textContent = '';
      saveBtn.disabled = true;
    }
  },

  async save() {
    if (!this.editingFile) return;

    const textarea = document.getElementById('editor-textarea');
    const content = textarea.value;

    try {
      const result = await AdminAPI.saveContent(
        this.editingFile.path,
        content,
        this.editingFile.modifiedAt
      );

      if (result.success) {
        this.editingFile.originalContent = content;
        this.editingFile.modifiedAt = result.modifiedAt;
        this.isDirty = false;
        this.updateDirtyIndicator();
        this.showToast('Saved successfully');
      } else if (result.error?.code === 'CONFLICT') {
        this.handleConflict(result.error.serverModifiedAt);
      } else {
        alert('Save failed: ' + result.error?.message);
      }
    } catch (error) {
      alert('Save failed: ' + error.message);
    }
  },

  async handleConflict(serverModifiedAt) {
    // 충돌 모달 표시
    const modal = document.getElementById('conflict-modal');
    modal.querySelector('.server-time').textContent = new Date(serverModifiedAt).toLocaleString();
    modal.style.display = 'flex';

    return new Promise((resolve) => {
      modal.querySelector('.btn-reload').onclick = async () => {
        modal.style.display = 'none';
        await this.openEditor(this.editingFile.path);  // 다시 로드
        resolve('reload');
      };
      modal.querySelector('.btn-overwrite').onclick = async () => {
        modal.style.display = 'none';
        // modifiedAt 없이 강제 저장
        this.editingFile.modifiedAt = null;
        await this.save();
        resolve('overwrite');
      };
    });
  },

  showUnsavedPrompt() {
    return new Promise((resolve) => {
      const modal = document.getElementById('unsaved-modal');
      modal.querySelector('.file-path').textContent = this.editingFile?.path || '';
      modal.style.display = 'flex';

      modal.querySelector('.btn-cancel').onclick = () => {
        modal.style.display = 'none';
        resolve('cancel');
      };
      modal.querySelector('.btn-discard').onclick = () => {
        modal.style.display = 'none';
        this.isDirty = false;
        resolve('discard');
      };
      modal.querySelector('.btn-save').onclick = async () => {
        modal.style.display = 'none';
        await this.save();
        resolve('save');
      };
    });
  },

  showToast(message) {
    // 간단한 토스트 알림
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 2000);
  }
};

// API 확장
AdminAPI.saveContent = async function(path, content, originalModifiedAt) {
  const body = { path, content };
  if (originalModifiedAt) body.originalModifiedAt = originalModifiedAt;

  const response = await fetch('/api/admin/content', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
    credentials: 'include'
  });
  return response.json();
};
```

### 4.2 CSS 추가

```css
/* Editor Container */
#editor-container {
  display: none;
  flex-direction: column;
  height: 100%;
  background: white;
  border-radius: 4px;
}

.editor-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  border-bottom: 1px solid var(--border-color);
  background: #f8f8f8;
}

.editor-path {
  font-family: monospace;
  font-size: 14px;
  color: #666;
}

.dirty-indicator {
  color: #ff9800;
  font-size: 20px;
  margin-left: 8px;
}

.editor-buttons {
  display: flex;
  gap: 8px;
}

.mode-edit, .mode-preview {
  padding: 4px 12px;
  border: 1px solid var(--border-color);
  background: white;
  cursor: pointer;
}

.mode-edit.active, .mode-preview.active {
  background: var(--primary-color);
  color: white;
  border-color: var(--primary-color);
}

#editor-textarea {
  flex: 1;
  padding: 16px;
  border: none;
  resize: none;
  font-family: 'Consolas', 'Monaco', monospace;
  font-size: 14px;
  line-height: 1.6;
  tab-size: 2;
}

#editor-textarea:focus {
  outline: none;
}

#editor-preview {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
}

.btn-save:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 12px 24px;
  border-radius: 4px;
  z-index: 2000;
  animation: fadeIn 0.2s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(10px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}
```

---

## 5. 테스트 섹션

### 5.1 테스트 시나리오 (Playwright)

#### TC-601: 편집기 열기

```
Given: 파일 트리에서 .md 파일 존재
When: 컨텍스트 메뉴 → Edit
Then: 편집기 UI 표시
And: 원본 내용 로드됨
```

#### TC-602: 편집 모드 전환

```
Given: 편집기 열림
When: Preview 버튼 클릭
Then: 미리보기 모드로 전환
And: 마크다운 렌더링 표시
When: Edit 버튼 클릭
Then: 편집 모드로 전환
```

#### TC-603: Dirty 상태 표시

```
Given: 편집기 열림
When: 텍스트 수정
Then: Dirty 표시기 [●] 표시
And: Save 버튼 활성화
```

#### TC-604: 저장 (Ctrl+S)

```
Given: Dirty 상태
When: Ctrl+S
Then: 파일 저장됨
And: Dirty 표시기 사라짐
And: "Saved successfully" 토스트
```

#### TC-605: 미저장 경고 (다른 파일 선택)

```
Given: Dirty 상태
When: 다른 파일 클릭
Then: 미저장 경고 모달 표시
When: Save 클릭
Then: 저장 후 다른 파일 열림
```

#### TC-606: 미저장 경고 (Discard)

```
Given: Dirty 상태
When: 다른 파일 클릭 → 모달 → Discard
Then: 변경 사항 버려짐
And: 다른 파일 열림
```

#### TC-607: 동시 편집 충돌

```
Given: 파일 A 편집 중
And: 다른 사용자가 파일 A 수정
When: 저장 시도
Then: 충돌 모달 표시
When: Reload 클릭
Then: 서버 버전으로 새로고침
```

#### TC-608: 브라우저 닫기 경고

```
Given: Dirty 상태
When: 브라우저 탭 닫기 시도
Then: 브라우저 기본 경고 표시
```

### 5.2 테스트 코드 구조

```javascript
// test/admin-editor.spec.js
test.describe('Editor', () => {
  test('open editor', async ({ page }) => { /* TC-601 */ });
  test('toggle edit/preview mode', async ({ page }) => { /* TC-602 */ });
  test('dirty indicator', async ({ page }) => { /* TC-603 */ });
  test('save with Ctrl+S', async ({ page }) => { /* TC-604 */ });
  test('unsaved warning on file change', async ({ page }) => { /* TC-605 */ });
  test('discard changes', async ({ page }) => { /* TC-606 */ });
  test('conflict handling', async ({ page }) => { /* TC-607 */ });
});
```

---

## 6. 회귀테스트 실행 조건

- [ ] Phase 1~5 테스트 전체
- [ ] 신규 편집기 테스트 전체

---

## 7. 완료 조건

- [ ] 모든 구현 항목 체크리스트 완료 (TASK-601 ~ TASK-620)
- [ ] 모든 테스트 시나리오 통과 (TC-601 ~ TC-608)
- [ ] 회귀테스트 100% 통과

---

*Phase 6 문서 끝*
