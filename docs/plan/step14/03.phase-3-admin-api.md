# Phase 3: 관리자 API 구현

| 항목 | 내용 |
|------|------|
| **Phase** | 3 |
| **예상 시간** | 13시간 |
| **선행 조건** | Phase 2 완료 |
| **관련 요구사항** | REQ-TREE-001, REQ-TREE-003, REQ-EDIT-001, REQ-EDIT-003, REQ-FILE-001~005, REQ-DND-001~003, NFR-SEC-002 |

---

## 1. 목표 및 범위

### 1.1 목표

- 파일 트리 API (모든 파일 타입 포함)
- 파일 내용 조회/저장 API
- 파일/폴더 생성, 이름 변경, 이동, 삭제 API

### 1.2 범위

**포함:**
- GET /api/admin/tree
- GET /api/admin/content
- PUT /api/admin/content
- POST /api/admin/create
- PUT /api/admin/rename
- PUT /api/admin/move
- DELETE /api/admin/entry

**제외:**
- 클라이언트 UI (Phase 4~7)
- 파일 업로드 (기존 API 사용)

---

## 2. 아키텍처 참조

> 참조: [00-1.architecture.md](00-1.architecture.md) - 3.2.2 API 상세 명세

### 2.1 관련 컴포넌트

```
src/routes/admin-api.js                    ← 확장
src/controllers/admin/admin-tree-controller.js   ← 신규
src/controllers/admin/admin-file-controller.js   ← 신규
src/controllers/admin/admin-move-controller.js   ← 신규
src/services/tree-service.js               ← 확장
src/services/file-service.js               ← 확장
```

---

## 3. 구현 항목 체크리스트

### 3.1 tree-service.js 확장

- [ ] **TASK-301**: getDirectoryTree() 옵션 추가
  - `includeAllFiles`: true면 모든 파일 포함
  - `includeMetadata`: true면 size, modifiedAt 포함

- [ ] **TASK-302**: 파일 메타데이터 수집 로직 추가
  - fs.stat()으로 size, mtime 조회

### 3.2 admin-tree-controller.js

- [ ] **TASK-303**: getTree() 핸들러 구현
  - tree-service.getDirectoryTree(config, logger, path, { includeAllFiles: true, includeMetadata: true })
  - 응답: { success: true, tree: [...] }

### 3.3 file-service.js 확장

- [ ] **TASK-304**: saveContent() 함수 구현
  - 내용 저장
  - modifiedAt 반환

- [ ] **TASK-305**: createFile() 함수 구현
  - 파일 생성 (초기 내용 포함)
  - 이미 존재하면 에러

- [ ] **TASK-306**: createDirectory() 함수 구현
  - 폴더 생성
  - 이미 존재하면 에러

- [ ] **TASK-307**: renameEntry() 함수 구현
  - 파일/폴더 이름 변경
  - 대상 이미 존재하면 에러

- [ ] **TASK-308**: moveEntries() 함수 구현
  - 여러 파일/폴더를 대상 디렉토리로 이동
  - 자기 하위로 이동 방지 검증

### 3.4 admin-file-controller.js

- [ ] **TASK-309**: getContent() 핸들러 구현
  - 경로 검증
  - 파일 내용 + 메타데이터 반환

- [ ] **TASK-310**: saveContent() 핸들러 구현
  - 경로 검증
  - write 권한 확인
  - 동시 편집 충돌 감지 (originalModifiedAt)

- [ ] **TASK-311**: createEntry() 핸들러 구현
  - 경로 검증
  - write 권한 확인
  - type에 따라 file/directory 생성

- [ ] **TASK-312**: deleteEntry() 핸들러 구현
  - 경로 검증
  - delete 권한 확인
  - 여러 경로 일괄 삭제

### 3.5 admin-move-controller.js

- [ ] **TASK-313**: renameEntry() 핸들러 구현
  - 경로 검증
  - write 권한 확인
  - 파일명 유효성 검증

- [ ] **TASK-314**: moveEntries() 핸들러 구현
  - 경로 검증
  - write 권한 확인
  - 자기 하위 이동 방지

### 3.6 admin-api.js 확장

- [ ] **TASK-315**: GET /tree 라우트 추가
- [ ] **TASK-316**: GET /content 라우트 추가
- [ ] **TASK-317**: PUT /content 라우트 추가
- [ ] **TASK-318**: POST /create 라우트 추가
- [ ] **TASK-319**: PUT /rename 라우트 추가
- [ ] **TASK-320**: PUT /move 라우트 추가
- [ ] **TASK-321**: DELETE /entry 라우트 추가

---

## 4. 상세 구현 명세

### 4.1 tree-service.js 확장

```javascript
// 기존 getDirectoryTree 확장
async function getDirectoryTree(config, logger, userPath, options = {}) {
  const { includeAllFiles = false, includeMetadata = false } = options;

  // ... 기존 로직

  for (const entry of entries) {
    // 파일 필터링
    if (!includeAllFiles && !entry.name.endsWith('.md')) {
      continue;
    }

    const node = {
      name: entry.name,
      path: entryPath,
      type: entry.isDirectory() ? 'directory' : 'file'
    };

    if (!entry.isDirectory()) {
      node.extension = path.extname(entry.name).toLowerCase();

      if (includeMetadata) {
        const stats = await fs.stat(fullPath);
        node.size = stats.size;
        node.modifiedAt = stats.mtime.toISOString();
      }
    }

    // ... children 처리
  }
}
```

### 4.2 file-service.js 확장

```javascript
// 신규 함수들

async function getContentWithMeta(config, logger, userPath) {
  const safePath = validatePath(config.docsRoot, userPath);
  const stats = await fs.stat(safePath);

  if (stats.isDirectory()) {
    throw new Error('INVALID_PATH: Cannot read directory as file');
  }

  const content = await fs.readFile(safePath, 'utf-8');

  return {
    path: userPath,
    content,
    encoding: 'utf-8',
    size: stats.size,
    modifiedAt: stats.mtime.toISOString()
  };
}

async function saveContent(config, logger, userPath, content, originalModifiedAt) {
  const safePath = validatePath(config.docsRoot, userPath);

  // 동시 편집 충돌 감지
  if (originalModifiedAt) {
    const stats = await fs.stat(safePath);
    const serverModifiedAt = stats.mtime.toISOString();

    if (new Date(serverModifiedAt) > new Date(originalModifiedAt)) {
      const error = new Error('CONFLICT: File was modified by another user');
      error.code = 'CONFLICT';
      error.serverModifiedAt = serverModifiedAt;
      throw error;
    }
  }

  await fs.writeFile(safePath, content, 'utf-8');
  const newStats = await fs.stat(safePath);

  return {
    path: userPath,
    size: newStats.size,
    modifiedAt: newStats.mtime.toISOString()
  };
}

async function createFile(config, logger, userPath, content = '') {
  const safePath = validatePath(config.docsRoot, userPath);

  // 이미 존재하면 에러
  try {
    await fs.access(safePath);
    throw new Error('ALREADY_EXISTS: File already exists');
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }

  // 상위 디렉토리 확인
  const parentDir = path.dirname(safePath);
  await fs.access(parentDir);

  await fs.writeFile(safePath, content, 'utf-8');

  return { path: userPath, type: 'file' };
}

async function createDirectory(config, logger, userPath) {
  const safePath = validatePath(config.docsRoot, userPath);

  // 이미 존재하면 에러
  try {
    await fs.access(safePath);
    throw new Error('ALREADY_EXISTS: Directory already exists');
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }

  await fs.mkdir(safePath);

  return { path: userPath, type: 'directory' };
}

async function renameEntry(config, logger, oldPath, newName) {
  const safePath = validatePath(config.docsRoot, oldPath);
  const parentDir = path.dirname(safePath);
  const newPath = path.join(parentDir, newName);

  // 파일명 유효성 검사
  if (/[<>:"|?*\x00-\x1f]/.test(newName)) {
    throw new Error('INVALID_NAME: Filename contains invalid characters');
  }

  // 대상이 이미 존재하면 에러
  try {
    await fs.access(newPath);
    throw new Error('ALREADY_EXISTS: Target name already exists');
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }

  await fs.rename(safePath, newPath);

  const newUserPath = path.join(path.dirname(oldPath), newName);
  return { oldPath, newPath: newUserPath };
}

async function moveEntries(config, logger, sourcePaths, targetDirectory) {
  const targetSafePath = validatePath(config.docsRoot, targetDirectory);

  // 대상이 디렉토리인지 확인
  const targetStats = await fs.stat(targetSafePath);
  if (!targetStats.isDirectory()) {
    throw new Error('INVALID_TARGET: Target must be a directory');
  }

  const results = { moved: [], errors: [] };

  for (const sourcePath of sourcePaths) {
    try {
      const sourceSafePath = validatePath(config.docsRoot, sourcePath);
      const fileName = path.basename(sourceSafePath);
      const destPath = path.join(targetSafePath, fileName);

      // 자기 하위로 이동 방지
      if (destPath.startsWith(sourceSafePath + path.sep)) {
        throw new Error('INVALID_MOVE: Cannot move into self');
      }

      await fs.rename(sourceSafePath, destPath);

      results.moved.push({
        from: sourcePath,
        to: path.join(targetDirectory, fileName)
      });
    } catch (err) {
      results.errors.push({ path: sourcePath, error: err.message });
    }
  }

  return results;
}
```

### 4.3 admin-file-controller.js

```javascript
// src/controllers/admin/admin-file-controller.js
const fileService = require('../../services/file-service');

async function getContent(req, res, next) {
  try {
    const { path: filePath } = req.query;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!filePath) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PATH', message: 'Path is required' }
      });
    }

    const result = await fileService.getContentWithMeta(config, logger, filePath);
    res.json({ success: true, ...result });
  } catch (error) {
    if (error.message.startsWith('INVALID_PATH') || error.code === 'ENOENT') {
      return res.status(404).json({
        success: false,
        error: { code: 'NOT_FOUND', message: 'File not found' }
      });
    }
    next(error);
  }
}

async function saveContent(req, res, next) {
  try {
    const { path: filePath, content, originalModifiedAt } = req.body;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!filePath || content === undefined) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PARAMS', message: 'Path and content are required' }
      });
    }

    const result = await fileService.saveContent(config, logger, filePath, content, originalModifiedAt);
    res.json({ success: true, ...result });
  } catch (error) {
    if (error.code === 'CONFLICT') {
      return res.status(409).json({
        success: false,
        error: {
          code: 'CONFLICT',
          message: error.message,
          serverModifiedAt: error.serverModifiedAt
        }
      });
    }
    next(error);
  }
}

async function createEntry(req, res, next) {
  try {
    const { path: entryPath, type, content } = req.body;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!entryPath || !type) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PARAMS', message: 'Path and type are required' }
      });
    }

    let result;
    if (type === 'file') {
      result = await fileService.createFile(config, logger, entryPath, content || '');
    } else if (type === 'directory') {
      result = await fileService.createDirectory(config, logger, entryPath);
    } else {
      return res.status(400).json({
        success: false,
        error: { code: 'INVALID_TYPE', message: 'Type must be "file" or "directory"' }
      });
    }

    res.status(201).json({ success: true, ...result });
  } catch (error) {
    if (error.message.startsWith('ALREADY_EXISTS')) {
      return res.status(409).json({
        success: false,
        error: { code: 'ALREADY_EXISTS', message: error.message }
      });
    }
    next(error);
  }
}

async function deleteEntry(req, res, next) {
  try {
    const { paths } = req.body;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!paths || !Array.isArray(paths) || paths.length === 0) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PATHS', message: 'Paths array is required' }
      });
    }

    const deleted = [];
    for (const p of paths) {
      try {
        await fileService.deleteEntryData(config, logger, p);
        deleted.push(p);
      } catch (err) {
        // 존재하지 않는 경로는 무시 (부분 성공)
        if (err.code !== 'ENOENT') throw err;
      }
    }

    res.json({ success: true, deleted });
  } catch (error) {
    next(error);
  }
}

module.exports = { getContent, saveContent, createEntry, deleteEntry };
```

### 4.4 admin-move-controller.js

```javascript
// src/controllers/admin/admin-move-controller.js
const fileService = require('../../services/file-service');

async function renameEntry(req, res, next) {
  try {
    const { oldPath, newName } = req.body;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!oldPath || !newName) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PARAMS', message: 'oldPath and newName are required' }
      });
    }

    const result = await fileService.renameEntry(config, logger, oldPath, newName);
    res.json({ success: true, ...result });
  } catch (error) {
    if (error.message.startsWith('INVALID_NAME')) {
      return res.status(400).json({
        success: false,
        error: { code: 'INVALID_NAME', message: error.message }
      });
    }
    if (error.message.startsWith('ALREADY_EXISTS')) {
      return res.status(409).json({
        success: false,
        error: { code: 'ALREADY_EXISTS', message: error.message }
      });
    }
    next(error);
  }
}

async function moveEntries(req, res, next) {
  try {
    const { sourcePaths, targetDirectory } = req.body;
    const config = req.app.locals.config;
    const logger = req.app.locals.logger;

    if (!sourcePaths || !Array.isArray(sourcePaths) || !targetDirectory) {
      return res.status(400).json({
        success: false,
        error: { code: 'MISSING_PARAMS', message: 'sourcePaths and targetDirectory are required' }
      });
    }

    const result = await fileService.moveEntries(config, logger, sourcePaths, targetDirectory);
    res.json({ success: true, ...result });
  } catch (error) {
    if (error.message.startsWith('INVALID_TARGET')) {
      return res.status(400).json({
        success: false,
        error: { code: 'INVALID_TARGET', message: error.message }
      });
    }
    next(error);
  }
}

module.exports = { renameEntry, moveEntries };
```

---

## 5. 테스트 섹션

### 5.1 테스트 시나리오

#### TC-301: 파일 트리 조회 (모든 파일 포함)

```
Given: docsRoot에 .md, .txt, .png 파일 존재
When: GET /api/admin/tree
Then: 200 응답
And: tree에 모든 파일 타입 포함
And: 각 파일에 size, modifiedAt 포함
```

#### TC-302: 파일 내용 조회

```
Given: /test/doc.md 파일 존재
When: GET /api/admin/content?path=/test/doc.md
Then: 200 응답
And: content에 파일 내용 포함
And: modifiedAt 포함
```

#### TC-303: 파일 저장

```
Given: /test/doc.md 파일 존재, 세션에 write 권한
When: PUT /api/admin/content { path, content }
Then: 200 응답
And: 파일 내용 변경됨
```

#### TC-304: 동시 편집 충돌

```
Given: 파일이 다른 사용자에 의해 수정됨
When: PUT /api/admin/content { path, content, originalModifiedAt }
Then: 409 응답
And: error.code === "CONFLICT"
And: serverModifiedAt 포함
```

#### TC-305: 파일 생성

```
Given: /test/new.md 존재하지 않음
When: POST /api/admin/create { path: "/test/new.md", type: "file", content: "# New" }
Then: 201 응답
And: 파일 생성됨
```

#### TC-306: 폴더 생성

```
Given: /test/newdir 존재하지 않음
When: POST /api/admin/create { path: "/test/newdir", type: "directory" }
Then: 201 응답
And: 폴더 생성됨
```

#### TC-307: 이름 변경

```
Given: /test/old.md 존재
When: PUT /api/admin/rename { oldPath: "/test/old.md", newName: "new.md" }
Then: 200 응답
And: 파일명 변경됨
```

#### TC-308: 파일 이동

```
Given: /folder1/file.md 존재, /folder2 존재
When: PUT /api/admin/move { sourcePaths: ["/folder1/file.md"], targetDirectory: "/folder2" }
Then: 200 응답
And: 파일이 /folder2/file.md로 이동됨
```

#### TC-309: 자기 하위로 이동 방지

```
Given: /folder1 존재
When: PUT /api/admin/move { sourcePaths: ["/folder1"], targetDirectory: "/folder1/sub" }
Then: 응답에 errors 포함
And: error.message에 "Cannot move into self" 포함
```

#### TC-310: 파일 삭제

```
Given: /test/delete.md 존재
When: DELETE /api/admin/entry { paths: ["/test/delete.md"] }
Then: 200 응답
And: 파일 삭제됨
```

### 5.2 테스트 코드 구조

```javascript
// test/test-admin-api.js
describe('Admin API', () => {
  describe('GET /api/admin/tree', () => {
    it('should include all file types', async () => { /* TC-301 */ });
  });

  describe('GET /api/admin/content', () => {
    it('should return file content with metadata', async () => { /* TC-302 */ });
  });

  describe('PUT /api/admin/content', () => {
    it('should save file content', async () => { /* TC-303 */ });
    it('should detect conflict', async () => { /* TC-304 */ });
  });

  describe('POST /api/admin/create', () => {
    it('should create file', async () => { /* TC-305 */ });
    it('should create directory', async () => { /* TC-306 */ });
  });

  describe('PUT /api/admin/rename', () => {
    it('should rename entry', async () => { /* TC-307 */ });
  });

  describe('PUT /api/admin/move', () => {
    it('should move entries', async () => { /* TC-308 */ });
    it('should prevent moving into self', async () => { /* TC-309 */ });
  });

  describe('DELETE /api/admin/entry', () => {
    it('should delete entries', async () => { /* TC-310 */ });
  });
});
```

---

## 6. 회귀테스트 실행 조건

- [ ] Phase 1, 2 테스트 전체
- [ ] 기존 tree-service 테스트
- [ ] 기존 file-service 테스트
- [ ] 신규 Admin API 테스트 전체

---

## 7. 완료 조건

- [ ] 모든 구현 항목 체크리스트 완료 (TASK-301 ~ TASK-321)
- [ ] 모든 테스트 시나리오 통과 (TC-301 ~ TC-310)
- [ ] 회귀테스트 100% 통과

---

*Phase 3 문서 끝*
