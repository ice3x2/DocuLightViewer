# Phase 7: 드래그앤드롭 및 마무리

| 항목 | 내용 |
|------|------|
| **Phase** | 7 |
| **예상 시간** | 10시간 |
| **선행 조건** | Phase 6 완료 |
| **관련 요구사항** | REQ-DND-001~005, REQ-URL-003 |

---

## 1. 목표 및 범위

### 1.1 목표

- 드래그앤드롭으로 파일/폴더 이동
- 부모 폴더로 이동 (트리 최상단 드롭)
- UI 폴리싱 및 마무리
- URL 동기화 완성

### 1.2 범위

**포함:**
- DragDropModule
- 드롭 영역 하이라이트
- 이동 제한 검증 (자기 하위 이동 방지)
- 키보드 단축키 완성
- 반응형 레이아웃 개선

**제외:**
- 외부 파일 드롭 (업로드)

---

## 2. 아키텍처 참조

> 참조: [00-1.architecture.md](00-1.architecture.md) - 3.3.2 상태 관리

### 2.1 관련 컴포넌트

```
public/js/admin.js   ← DragDropModule 추가
public/css/admin.css ← 드래그 상태 스타일 추가
```

---

## 3. 구현 항목 체크리스트

### 3.1 DragDropModule

- [ ] **TASK-701**: handleDragStart(event, path)
  - dataTransfer 설정
  - dragSource 저장
  - 드래그 중 스타일 적용

- [ ] **TASK-702**: handleDragOver(event, targetPath)
  - 기본 동작 방지
  - 유효한 드롭 대상 확인
  - 하이라이트 표시

- [ ] **TASK-703**: handleDragLeave(event)
  - 하이라이트 제거

- [ ] **TASK-704**: handleDrop(event, targetPath)
  - 이동 실행
  - API 호출
  - 트리 새로고침

- [ ] **TASK-705**: handleDragEnd(event)
  - 상태 초기화
  - 드래그 스타일 제거

- [ ] **TASK-706**: isValidDropTarget(sourcePath, targetPath)
  - 자기 자신으로 이동 방지
  - 자기 하위로 이동 방지
  - 파일은 디렉토리에만 드롭 가능

### 3.2 부모 폴더 이동

- [ ] **TASK-707**: 트리 최상단에 드롭존 추가
  - "Move to parent" 영역
  - 시각적 피드백

- [ ] **TASK-708**: handleMoveToParent(paths)
  - 부모 경로 계산
  - move API 호출

### 3.3 드래그 피드백

- [ ] **TASK-709**: 드래그 이미지 커스터마이징
  - 파일 이름 표시
  - 다중 선택 시 개수 표시

- [ ] **TASK-710**: 유효/무효 드롭 표시
  - 유효: 녹색 테두리
  - 무효: 빨간색 테두리 + 금지 커서

### 3.4 이벤트 바인딩

- [ ] **TASK-711**: draggable 속성 설정
  - 트리 항목에 draggable="true"

- [ ] **TASK-712**: 이벤트 리스너 바인딩
  - dragstart, dragover, dragleave, drop, dragend

### 3.5 URL 동기화 완성

- [ ] **TASK-713**: 파일 이동 후 URL 업데이트
  - 현재 보기 파일이 이동된 경우

- [ ] **TASK-714**: 북마크 지원
  - /admin/path/to/file 형식 유지

### 3.6 키보드 단축키 완성

- [ ] **TASK-715**: 전체 단축키 목록 구현
  - Ctrl+C: 복사
  - Ctrl+X: 잘라내기
  - Ctrl+V: 붙여넣기

- [ ] **TASK-716**: 단축키 충돌 방지
  - 편집 중일 때 트리 단축키 비활성화

### 3.7 UI 폴리싱

- [ ] **TASK-717**: 로딩 표시
  - API 호출 중 스피너

- [ ] **TASK-718**: 에러 처리 개선
  - 사용자 친화적 메시지
  - 재시도 옵션

- [ ] **TASK-719**: 접근성 개선
  - aria-* 속성
  - 키보드 네비게이션

- [ ] **TASK-720**: 반응형 레이아웃
  - 모바일 사이드바 토글

---

## 4. 상세 구현 명세

### 4.1 DragDropModule

```javascript
const DragDropModule = {
  dragSource: null,       // 드래그 중인 항목
  dragPaths: [],          // 다중 선택 시 모든 경로
  dropTarget: null,       // 현재 드롭 대상

  setupDraggable(element, path, type) {
    element.setAttribute('draggable', 'true');

    element.addEventListener('dragstart', (e) => this.handleDragStart(e, path));
    element.addEventListener('dragover', (e) => this.handleDragOver(e, path, type));
    element.addEventListener('dragleave', (e) => this.handleDragLeave(e));
    element.addEventListener('drop', (e) => this.handleDrop(e, path, type));
    element.addEventListener('dragend', (e) => this.handleDragEnd(e));
  },

  handleDragStart(event, path) {
    // 선택된 항목이 있으면 모두 드래그
    if (AdminState.selectedPaths.includes(path)) {
      this.dragPaths = [...AdminState.selectedPaths];
    } else {
      this.dragPaths = [path];
    }

    this.dragSource = path;

    // 드래그 이미지
    const dragImage = this.createDragImage(this.dragPaths);
    document.body.appendChild(dragImage);
    event.dataTransfer.setDragImage(dragImage, 10, 10);
    setTimeout(() => dragImage.remove(), 0);

    // 데이터 설정
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', JSON.stringify(this.dragPaths));

    // 드래그 중 스타일
    this.dragPaths.forEach(p => {
      const el = document.querySelector(`[data-path="${p}"]`);
      if (el) el.classList.add('dragging');
    });
  },

  handleDragOver(event, targetPath, targetType) {
    event.preventDefault();

    // 유효성 검사
    const isValid = this.isValidDropTarget(targetPath, targetType);

    if (isValid) {
      event.dataTransfer.dropEffect = 'move';
      const el = document.querySelector(`[data-path="${targetPath}"]`);
      if (el && this.dropTarget !== targetPath) {
        // 이전 하이라이트 제거
        document.querySelectorAll('.drop-target').forEach(e => e.classList.remove('drop-target'));
        el.classList.add('drop-target');
        this.dropTarget = targetPath;
      }
    } else {
      event.dataTransfer.dropEffect = 'none';
    }
  },

  handleDragLeave(event) {
    const el = event.currentTarget;
    if (el) el.classList.remove('drop-target');
    if (el && el.dataset.path === this.dropTarget) {
      this.dropTarget = null;
    }
  },

  async handleDrop(event, targetPath, targetType) {
    event.preventDefault();
    event.stopPropagation();

    // 하이라이트 제거
    document.querySelectorAll('.drop-target').forEach(e => e.classList.remove('drop-target'));

    if (!this.isValidDropTarget(targetPath, targetType)) {
      return;
    }

    // 이동 실행
    const targetDir = targetType === 'directory' ? targetPath : this.getParentPath(targetPath);

    try {
      const result = await AdminAPI.moveEntries(this.dragPaths, targetDir);
      if (result.success) {
        // 현재 보기 파일이 이동된 경우 URL 업데이트
        const movedFile = result.moved.find(m => m.from === AdminState.currentViewPath);
        if (movedFile) {
          URLModule.navigateTo(movedFile.to);
        }

        await TreeModule.loadTree();
        EditorModule.showToast(`Moved ${result.moved.length} item(s)`);
      }
    } catch (error) {
      alert('Move failed: ' + error.message);
    }

    this.resetDragState();
  },

  handleDragEnd(event) {
    this.resetDragState();
  },

  resetDragState() {
    // 드래그 스타일 제거
    document.querySelectorAll('.dragging').forEach(e => e.classList.remove('dragging'));
    document.querySelectorAll('.drop-target').forEach(e => e.classList.remove('drop-target'));

    this.dragSource = null;
    this.dragPaths = [];
    this.dropTarget = null;
  },

  isValidDropTarget(targetPath, targetType) {
    // 자기 자신으로 이동 불가
    if (this.dragPaths.includes(targetPath)) return false;

    // 파일에는 드롭 불가 (디렉토리만)
    if (targetType === 'file') return false;

    // 자기 하위로 이동 불가
    for (const sourcePath of this.dragPaths) {
      if (targetPath.startsWith(sourcePath + '/')) return false;
    }

    return true;
  },

  getParentPath(path) {
    const parts = path.split('/').filter(Boolean);
    parts.pop();
    return '/' + parts.join('/');
  },

  createDragImage(paths) {
    const div = document.createElement('div');
    div.className = 'drag-image';
    div.style.cssText = 'position: absolute; top: -9999px; background: white; padding: 8px 12px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);';

    if (paths.length === 1) {
      div.textContent = paths[0].split('/').pop();
    } else {
      div.textContent = `${paths.length} items`;
    }

    return div;
  }
};

// API 확장
AdminAPI.moveEntries = async function(sourcePaths, targetDirectory) {
  const response = await fetch('/api/admin/move', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sourcePaths, targetDirectory }),
    credentials: 'include'
  });
  return response.json();
};
```

### 4.2 부모 이동 드롭존

```javascript
// TreeModule 확장
function renderTree() {
  const container = document.getElementById('file-tree');
  container.innerHTML = '';

  // 부모 이동 드롭존
  const parentDropZone = document.createElement('div');
  parentDropZone.className = 'parent-drop-zone';
  parentDropZone.textContent = '⬆️ Move to parent folder';
  parentDropZone.style.display = 'none';

  parentDropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    parentDropZone.classList.add('drop-target');
  });
  parentDropZone.addEventListener('dragleave', () => {
    parentDropZone.classList.remove('drop-target');
  });
  parentDropZone.addEventListener('drop', async (e) => {
    e.preventDefault();
    parentDropZone.classList.remove('drop-target');

    // 각 항목의 부모로 이동
    for (const path of DragDropModule.dragPaths) {
      const parentPath = DragDropModule.getParentPath(DragDropModule.getParentPath(path));
      if (parentPath) {
        await AdminAPI.moveEntries([path], parentPath);
      }
    }
    await TreeModule.loadTree();
  });

  container.appendChild(parentDropZone);

  // 드래그 시작 시 드롭존 표시
  document.addEventListener('dragstart', () => {
    parentDropZone.style.display = 'block';
  });
  document.addEventListener('dragend', () => {
    parentDropZone.style.display = 'none';
  });

  // 트리 노드 렌더링
  this.renderNodes(container, AdminState.fileTree, 0);
}
```

### 4.3 CSS 추가

```css
/* Drag and Drop */
.tree-item.dragging {
  opacity: 0.5;
}

.tree-item.drop-target {
  background: #e8f5e9 !important;
  border: 2px dashed #4caf50;
}

.tree-item.drop-invalid {
  background: #ffebee !important;
  border: 2px dashed #f44336;
  cursor: not-allowed;
}

.parent-drop-zone {
  display: none;
  padding: 12px 16px;
  text-align: center;
  color: #666;
  border: 2px dashed transparent;
  margin: 4px 8px;
}

.parent-drop-zone.drop-target {
  background: #e3f2fd;
  border-color: var(--primary-color);
}

/* Loading */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3000;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Mobile */
@media (max-width: 768px) {
  #admin-app {
    grid-template-columns: 1fr;
  }

  #admin-sidebar {
    position: fixed;
    left: -280px;
    top: var(--toolbar-height);
    height: calc(100% - var(--toolbar-height));
    z-index: 500;
    transition: left 0.3s;
  }

  #admin-sidebar.open {
    left: 0;
  }

  #sidebar-resizer {
    display: none;
  }

  .toolbar-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .menu-toggle {
    display: block;
  }
}
```

---

## 5. 테스트 섹션

### 5.1 테스트 시나리오 (Playwright)

#### TC-701: 파일 드래그앤드롭 이동

```
Given: folder1/file.md 존재, folder2 존재
When: file.md를 folder2로 드래그앤드롭
Then: folder2/file.md로 이동됨
```

#### TC-702: 폴더 드래그앤드롭 이동

```
Given: folder1 존재, folder2 존재
When: folder1을 folder2로 드래그앤드롭
Then: folder2/folder1으로 이동됨
```

#### TC-703: 자기 하위로 이동 방지

```
Given: folder1 존재
When: folder1을 folder1/sub로 드래그 시도
Then: 드롭 불가 (빨간색 하이라이트)
And: 이동 실행되지 않음
```

#### TC-704: 부모로 이동

```
Given: folder1/subfolder 존재
When: subfolder를 트리 최상단 드롭존에 드롭
Then: /subfolder로 이동됨
```

#### TC-705: 다중 파일 드래그앤드롭

```
Given: file1.md, file2.md 선택됨
When: folder2로 드래그앤드롭
Then: 두 파일 모두 folder2로 이동됨
```

#### TC-706: 드롭 영역 하이라이트

```
Given: 파일 드래그 중
When: 폴더 위로 드래그
Then: 녹색 테두리 하이라이트
When: 파일 위로 드래그
Then: 드롭 불가 커서
```

#### TC-707: 키보드 단축키 (Ctrl+C/X/V)

```
Given: 파일 선택됨
When: Ctrl+X
Then: 클립보드에 cut 상태 저장
When: 폴더 선택 후 Ctrl+V
Then: 파일 이동됨
```

### 5.2 테스트 코드 구조

```javascript
// test/admin-dnd.spec.js
test.describe('Drag and Drop', () => {
  test('move file by drag', async ({ page }) => { /* TC-701 */ });
  test('move folder by drag', async ({ page }) => { /* TC-702 */ });
  test('prevent move into self', async ({ page }) => { /* TC-703 */ });
  test('move to parent', async ({ page }) => { /* TC-704 */ });
  test('multi-file drag', async ({ page }) => { /* TC-705 */ });
  test('drop zone highlight', async ({ page }) => { /* TC-706 */ });
  test('keyboard shortcuts', async ({ page }) => { /* TC-707 */ });
});
```

---

## 6. 회귀테스트 실행 조건

- [ ] Phase 1~6 테스트 전체
- [ ] 신규 드래그앤드롭 테스트 전체
- [ ] 전체 통합 테스트

---

## 7. 완료 조건

- [ ] 모든 구현 항목 체크리스트 완료 (TASK-701 ~ TASK-720)
- [ ] 모든 테스트 시나리오 통과 (TC-701 ~ TC-707)
- [ ] 회귀테스트 100% 통과
- [ ] 크로스 브라우저 테스트 완료

---

*Phase 7 문서 끝*
