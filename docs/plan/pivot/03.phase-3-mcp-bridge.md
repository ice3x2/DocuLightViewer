# Phase 3: MCP Bridge Process 구현

작성일: 2026-02-14
최종 업데이트: 2026-02-14

## 한 줄 요약

AI 에이전트(Claude Desktop, Claude Code 등)가 stdio 기반 MCP 프로토콜로 Electron GUI를 제어할 수 있도록, 경량 MCP stdio 서버를 구현하고 IPC 소켓으로 Electron에 브릿지한다.

---

## 1. 목표

별도 프로세스로 실행되는 경량 MCP stdio 서버(`mcp-server.js`)를 구현한다:
- `@modelcontextprotocol/sdk`의 `McpServer` + `StdioServerTransport` 사용
- 4개 MCP 도구 등록: `open_markdown`, `update_markdown`, `close_viewer`, `list_viewers`
- Named Pipe / Unix Socket으로 Electron Main Process에 연결
- Electron이 미실행 시 자동 실행 + 재시도
- stdout은 MCP 프로토콜 전용, 모든 디버그/에러 로그는 stderr

Phase 3 완료 후, Claude Desktop의 MCP 설정에 `mcp-server.js`를 등록하면 AI가 Markdown 뷰어를 제어할 수 있어야 한다.

## 2. 선행 조건

- Phase 2 완료 (Electron 앱 + IPC 소켓 서버 정상 동작)
- `@modelcontextprotocol/sdk` 패키지 설치 완료 (Phase 1에서 추가)

## 3. 아키텍처 참조

- `00-1.architecture.md` Section 1 (시스템 컨텍스트 — MCP Bridge 위치)
- `00-1.architecture.md` Section 3.3 (MCP Bridge 클래스 다이어그램)
- `00-1.architecture.md` Section 4.1 (open_markdown 시퀀스)
- `00-1.architecture.md` Section 5.3 (IPC 메시지 포맷)
- `00-2.tech-decisions.md` ADR-002 (분리 아키텍처), ADR-003 (Named Pipe / Unix Socket)

---

## 4. 죽은 코드 / 중복 방지 참고

### 4.1 기존 MCP 코드와의 관계

Phase 1에서 삭제된 `src/services/mcp/` (5개 파일)과 `src/routes/mcp.js`, `src/routes/context-mcp.js`는 Express HTTP 기반 JSON-RPC MCP 구현이었다. 새 `mcp-server.js`는:

| 항목 | 기존 (삭제됨) | 신규 (Phase 3) |
|------|--------------|----------------|
| 프로토콜 | HTTP JSON-RPC | stdio JSON-RPC (MCP SDK) |
| SDK | 없음 (수동 파싱) | `@modelcontextprotocol/sdk` |
| 도구 수 | 4+ (검색, 요약 등) | 4 (뷰어 제어 전용) |
| 프로세스 | Express 내장 | 별도 프로세스 |

**중복 코드 위험: 없음.** 기존 MCP 코드는 완전히 다른 목적(문서 검색/요약)이었고, 새 코드는 뷰어 GUI 제어 전용이다.

### 4.2 IPC 소켓 클라이언트 코드

IPC 소켓 연결 로직은 `mcp-server.js`에만 존재한다. `index.js`의 IPC 소켓 **서버** 코드와 대칭이지만 역할이 다르다(클라이언트 vs 서버). 공통 유틸리티로 추출하지 않는다 (00-2.tech-decisions.md "유틸리티 추출 금지" 원칙).

---

## 5. 구현 체크리스트

### 5.1 `src/main/mcp-server.js` — MCP Bridge 진입점

#### 서버 초기화

- [ ] import 문:
  ```javascript
  import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
  import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
  import net from 'node:net';
  import { spawn } from 'node:child_process';
  import { randomUUID } from 'node:crypto';
  import { platform } from 'node:os';
  import { fileURLToPath } from 'node:url';
  import path from 'node:path';
  ```
- [ ] package.json에 `"type": "module"` 추가 또는 `.mjs` 확장자 사용
  - 결정: `mcp-server.js`는 `@modelcontextprotocol/sdk`가 ESM이므로 ESM으로 작성
  - `index.js`와 `window-manager.js`는 Electron이 CJS를 기대하므로 CJS 유지
  - **해결책**: `mcp-server.mjs` 확장자 사용 (package.json `type` 변경 불필요)
- [ ] 서버 정보 정의:
  ```javascript
  const server = new McpServer({
    name: 'doclight',
    version: '1.0.0'
  });
  ```
- [ ] capabilities: `{ tools: {} }` (도구만 제공, resources/prompts 없음)

#### IPC 소켓 상수

- [ ] 소켓 경로:
  ```javascript
  const PIPE_PATH = platform() === 'win32'
    ? '\\\\.\\pipe\\doclight-ipc'
    : '/tmp/doclight-ipc.sock';
  ```
- [ ] 타임아웃: `const IPC_TIMEOUT = 10_000;` (10초)
- [ ] 최대 콘텐츠 크기: `const MAX_CONTENT_SIZE = 10 * 1024 * 1024;` (10MB)
- [ ] Electron 자동 실행 재시도: `const MAX_RETRIES = 10;`, `const RETRY_INTERVAL = 500;` (ms)

### 5.2 IPC 소켓 클라이언트

#### 상태 관리

- [ ] `let ipcSocket = null;` — 현재 소켓 연결
- [ ] `let pendingRequests = new Map();` — `Map<string, { resolve, reject, timer }>`
- [ ] `let ipcBuffer = '';` — ndjson 파싱 버퍼

#### connectToElectron()

- [ ] `net.connect(PIPE_PATH)` 시도
- [ ] 연결 성공:
  ```javascript
  ipcSocket = socket;
  ipcBuffer = '';
  socket.on('data', onIpcData);
  socket.on('error', onIpcError);
  socket.on('close', onIpcClose);
  ```
- [ ] 연결 실패: Electron 자동 실행 로직 호출

#### Electron 자동 실행 (autoLaunchElectron)

- [ ] Electron 앱 경로 결정:
  1. 환경변수 `DOCLIGHT_APP_PATH` 확인 (최우선)
  2. 플랫폼별 기본 경로:
     - Windows: `%LOCALAPPDATA%\Programs\doclight\DocLight.exe`
     - macOS: `/Applications/DocLight.app/Contents/MacOS/DocLight`
     - Linux: `/usr/bin/doclight`
  3. 개발 환경 fallback: `npx electron <project-root>`
- [ ] `spawn(electronPath, [], { detached: true, stdio: 'ignore' })`:
  - `detached: true` — Bridge 종료 후에도 Electron 유지
  - `stdio: 'ignore'` — Electron의 stdout/stderr 무시
  - `child.unref()` — Bridge의 이벤트 루프에서 분리
- [ ] 재시도 루프:
  ```javascript
  for (let i = 0; i < MAX_RETRIES; i++) {
    await sleep(RETRY_INTERVAL);
    try {
      await connectToElectron();
      return; // 성공
    } catch {
      // 다음 재시도
    }
  }
  throw new Error('Failed to connect to Electron after auto-launch');
  ```

#### sendIpcRequest(action, params)

- [ ] `id` 생성: `randomUUID()`
- [ ] 소켓 미연결 시 `connectToElectron()` 호출
- [ ] Promise 생성:
  ```javascript
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      pendingRequests.delete(id);
      reject(new Error(`IPC request timeout (${IPC_TIMEOUT}ms): ${action}`));
    }, IPC_TIMEOUT);

    pendingRequests.set(id, { resolve, reject, timer });
    ipcSocket.write(JSON.stringify({ id, action, params }) + '\n');
  });
  ```

#### onIpcData(chunk)

- [ ] `ipcBuffer += chunk.toString()`
- [ ] `ipcBuffer.split('\n')` 으로 줄 분리
- [ ] 마지막 불완전 줄은 buffer에 유지
- [ ] 각 완성된 줄에 대해 `handleIpcResponse(line)` 호출

#### handleIpcResponse(line)

- [ ] `JSON.parse(line)` → `{ id, result?, error? }`
- [ ] `pendingRequests.get(id)` 조회
- [ ] 존재하지 않으면 무시 (타임아웃 이후 도착한 응답)
- [ ] `clearTimeout(timer)`
- [ ] `pendingRequests.delete(id)`
- [ ] `error` 존재: `reject(new Error(error.message))`
- [ ] 그렇지 않으면: `resolve(result)`

#### onIpcError / onIpcClose

- [ ] 에러 로그 (`console.error` → stderr)
- [ ] `ipcSocket = null`
- [ ] 모든 pending requests를 reject (연결 끊김 에러)
- [ ] 재연결은 다음 `sendIpcRequest` 호출 시 자동 수행

### 5.3 MCP 도구 등록

#### open_markdown

- [ ] 스키마:
  ```javascript
  server.tool(
    'open_markdown',
    'Open a Markdown document in the DocLight viewer. Provide either content (raw Markdown string) or filePath (absolute path to .md file). Returns windowId for future reference.',
    {
      content:    { type: 'string', description: 'Raw Markdown content to display' },
      filePath:   { type: 'string', description: 'Absolute path to a .md file' },
      title:      { type: 'string', description: 'Window title (optional, auto-detected from content)' },
      foreground: { type: 'boolean', description: 'Bring window to front (default: true)' },
      size:       { type: 'string', enum: ['s', 'm', 'l', 'f'], description: 'Window size preset: s(480x680), m(720x1024), l(1080x1440), f(fullscreen). Default: m. Clamped to screen bounds.' }
    },
    async (args) => { ... }
  );
  ```
- [ ] 입력 검증:
  - `content`와 `filePath` 둘 다 없으면 에러: `"content 또는 filePath 중 하나는 필수입니다"`
  - `content` 제공 시 크기 검사: `Buffer.byteLength(content) > MAX_CONTENT_SIZE` 이면 에러: `"콘텐츠 크기가 10MB를 초과합니다"`
  - `size` 검증: 제공 시 `['s','m','l','f']` 중 하나인지 확인. 유효하지 않으면 기본값 `'m'` 사용
- [ ] IPC 전달: `sendIpcRequest('open_markdown', { content, filePath, title, foreground: foreground ?? true, size: size ?? 'm' })`
- [ ] 응답 반환:
  ```javascript
  return {
    content: [{
      type: 'text',
      text: `뷰어가 열렸습니다.\n- Window ID: ${result.windowId}\n- 제목: ${result.title}`
    }]
  };
  ```
- [ ] 에러 시:
  ```javascript
  return {
    content: [{ type: 'text', text: `오류: ${err.message}` }],
    isError: true
  };
  ```

#### update_markdown

- [ ] 스키마:
  ```javascript
  server.tool(
    'update_markdown',
    'Update the content of an existing DocLight viewer window. Requires windowId from a previous open_markdown call.',
    {
      windowId: { type: 'string', description: 'Target window ID (required)' },
      content:  { type: 'string', description: 'New Markdown content' },
      filePath: { type: 'string', description: 'New file path to load' },
      title:    { type: 'string', description: 'New window title (optional)' }
    },
    async (args) => { ... }
  );
  ```
- [ ] 입력 검증:
  - `windowId` 미제공 시 에러: `"windowId는 필수입니다"`
  - `content`와 `filePath` 둘 다 없으면 에러: `"content 또는 filePath 중 하나는 필수입니다"`
  - `content` 크기 검사 (동일)
- [ ] IPC 전달: `sendIpcRequest('update_markdown', { windowId, content, filePath, title })`
- [ ] 응답: `"뷰어가 업데이트되었습니다.\n- Window ID: ...\n- 제목: ..."`

#### close_viewer

- [ ] 스키마:
  ```javascript
  server.tool(
    'close_viewer',
    'Close DocLight viewer window(s). If windowId is provided, closes that specific window. Otherwise, closes all open windows.',
    {
      windowId: { type: 'string', description: 'Window ID to close (optional, omit to close all)' }
    },
    async (args) => { ... }
  );
  ```
- [ ] IPC 전달: `sendIpcRequest('close_viewer', { windowId: args.windowId })`
- [ ] 응답:
  - `windowId` 제공 시: `"뷰어를 닫았습니다. (Window ID: ...)"`
  - 미제공 시: `"모든 뷰어를 닫았습니다. (${result.closed}개)"`

#### list_viewers

- [ ] 스키마:
  ```javascript
  server.tool(
    'list_viewers',
    'List all currently open DocLight viewer windows.',
    {},
    async () => { ... }
  );
  ```
- [ ] IPC 전달: `sendIpcRequest('list_viewers', {})`
- [ ] 응답 포맷:
  ```javascript
  const lines = result.windows.map((w, i) =>
    `${i + 1}. ${w.title} (ID: ${w.windowId}${w.alwaysOnTop ? ', 항상 위' : ''})`
  );
  return {
    content: [{
      type: 'text',
      text: `열린 뷰어: ${result.windows.length}개\n${lines.join('\n') || '(없음)'}`
    }]
  };
  ```

### 5.4 서버 시작 및 종료

#### start()

- [ ] StdioServerTransport 생성
- [ ] `await server.connect(transport)` 호출
- [ ] stderr에 시작 로그: `console.error('[doclight-mcp] Server started')`

#### Graceful Shutdown

- [ ] `process.on('SIGTERM', shutdown)` 등록
- [ ] `process.on('SIGINT', shutdown)` 등록
- [ ] stdin EOF 감지: `process.stdin.on('end', shutdown)`
- [ ] `shutdown()` 함수:
  ```javascript
  async function shutdown() {
    console.error('[doclight-mcp] Shutting down...');

    // 1. 대기 중인 요청 완료 대기 (최대 5초)
    if (pendingRequests.size > 0) {
      console.error(`[doclight-mcp] Waiting for ${pendingRequests.size} pending requests...`);
      await Promise.race([
        Promise.allSettled([...pendingRequests.values()].map(p => p.resolve)),
        sleep(5000)
      ]);
    }

    // 2. 남은 pending requests 강제 reject
    for (const [id, { reject, timer }] of pendingRequests) {
      clearTimeout(timer);
      reject(new Error('Server shutting down'));
    }
    pendingRequests.clear();

    // 3. 소켓 연결 종료
    ipcSocket?.destroy();
    ipcSocket = null;

    // 4. MCP 서버 종료
    await server.close();

    process.exit(0);
  }
  ```

### 5.5 로깅 규칙

- [ ] `console.log()` 사용 금지 (stdout은 MCP 프로토콜 전용)
- [ ] 모든 디버그/정보/에러 로그: `console.error()` 사용 (stderr)
- [ ] 로그 형식: `[doclight-mcp] 메시지` 접두사 통일
- [ ] IPC 요청/응답 로그: action과 id만 기록, content 본문은 기록하지 않음 (크기 문제)

---

## 6. MCP 클라이언트 설정 예시

### Claude Desktop (`claude_desktop_config.json`)

```json
{
  "mcpServers": {
    "doclight": {
      "command": "node",
      "args": ["C:/path/to/DocLight/src/main/mcp-server.mjs"]
    }
  }
}
```

### Claude Code (`claude_code_config.json`)

```json
{
  "mcpServers": {
    "doclight": {
      "command": "node",
      "args": ["C:/path/to/DocLight/src/main/mcp-server.mjs"]
    }
  }
}
```

---

## 7. 에러 처리 매트릭스

| 상황 | 동작 | MCP 응답 |
|------|------|----------|
| Electron 미실행 | 자동 실행 + 500ms x 10 재시도 | 성공 시 정상 응답, 실패 시 `isError: true` |
| IPC 소켓 연결 실패 (재시도 소진) | 에러 반환 | `"Electron 앱에 연결할 수 없습니다. 앱이 설치되었는지 확인하세요."` |
| IPC 요청 타임아웃 (10초) | pending에서 제거, reject | `"요청 시간이 초과되었습니다 (10초)"` |
| 잘못된 windowId | Electron에서 에러 반환 | `"Window not found: <windowId>"` |
| content + filePath 둘 다 없음 | 로컬 검증 에러 | `"content 또는 filePath 중 하나는 필수입니다"` |
| content > 10MB | 로컬 검증 에러 | `"콘텐츠 크기가 10MB를 초과합니다"` |
| IPC 연결 중 끊김 | 재연결 (다음 요청 시) | 현재 요청만 에러 |
| stdin EOF (MCP 클라이언트 종료) | graceful shutdown | (프로세스 종료) |

---

## 8. 테스트 시나리오

### 8.1 정상 케이스

#### TC-1: Electron 실행 중에 open_markdown (content 모드)

```
Given: Electron DocLight 앱이 실행 중이고 IPC 소켓 서버가 리스닝 상태
When: MCP 클라이언트가 open_markdown 도구를 호출한다:
  { "content": "# Hello World\n\nThis is a test.", "foreground": true }
Then:
  - 새 BrowserWindow가 생성된다
  - 창 제목이 "Hello World"이다
  - MCP 응답: "뷰어가 열렸습니다.\n- Window ID: <uuid>\n- 제목: Hello World"
  - 응답의 isError가 false이다
```

#### TC-2: Electron 실행 중에 open_markdown (filePath 모드)

```
Given: Electron 실행 중, /docs/test.md 파일이 존재 (내용: "# File Test\n\nContent")
When: MCP 클라이언트가 open_markdown 도구를 호출한다:
  { "filePath": "/docs/test.md" }
Then:
  - 새 BrowserWindow가 생성된다
  - 파일 내용이 렌더링된다
  - 사이드바에 링크 트리가 표시된다
  - MCP 응답에 windowId와 title이 포함된다
```

#### TC-3: list_viewers — 창 없음

```
Given: Electron 실행 중, 열린 창이 0개
When: MCP 클라이언트가 list_viewers 도구를 호출한다
Then:
  - MCP 응답: "열린 뷰어: 0개\n(없음)"
```

#### TC-4: update_markdown — 기존 창 업데이트

```
Given: windowId "abc-123"인 창이 열려 있고 "# Old" 콘텐츠 표시 중
When: MCP 클라이언트가 update_markdown을 호출한다:
  { "windowId": "abc-123", "content": "# New Content" }
Then:
  - 기존 창의 콘텐츠가 "# New Content"로 변경된다
  - 창 제목이 "New Content"로 업데이트된다
  - MCP 응답: "뷰어가 업데이트되었습니다..."
```

#### TC-5: close_viewer — 전체 닫기

```
Given: 3개 창이 열린 상태
When: MCP 클라이언트가 close_viewer를 windowId 없이 호출한다
Then:
  - 3개 창이 모두 닫힌다
  - MCP 응답: "모든 뷰어를 닫았습니다. (3개)"
```

### 8.2 예외 케이스

#### TC-6: Electron 미실행 시 자동 실행

```
Given: Electron DocLight 앱이 실행되지 않은 상태
When: MCP 클라이언트가 open_markdown 도구를 호출한다
Then:
  - Bridge가 소켓 연결 실패를 감지한다
  - Electron 앱을 spawn한다
  - 500ms 간격으로 소켓 재연결을 시도한다
  - 최대 10회 (5초) 내에 연결에 성공한다
  - open_markdown이 정상 수행된다
  - MCP 응답에 windowId가 포함된다
```

#### TC-7: IPC 타임아웃

```
Given: Electron 앱이 실행 중이나 IPC 요청 처리가 10초 이상 걸리는 상황 (인위적)
When: MCP 클라이언트가 open_markdown 도구를 호출한다
Then:
  - 10초 후 타임아웃 발생
  - MCP 응답: isError=true, "요청 시간이 초과되었습니다 (10초)"
  - 타임아웃된 요청이 pendingRequests에서 제거된다
  - 이후 요청은 정상 처리 가능하다
```

#### TC-8: content와 filePath 둘 다 미제공

```
Given: Bridge가 정상 상태
When: MCP 클라이언트가 open_markdown을 빈 인자로 호출한다: {}
Then:
  - 로컬 검증에서 즉시 에러 (IPC 전송 없음)
  - MCP 응답: isError=true, "content 또는 filePath 중 하나는 필수입니다"
```

#### TC-9: Electron 자동 실행 실패 (10회 재시도 소진)

```
Given: Electron 앱이 설치되지 않은 환경, DOCLIGHT_APP_PATH도 미설정
When: MCP 클라이언트가 open_markdown을 호출한다
Then:
  - 자동 실행 시도 후 10회 재시도 모두 실패
  - MCP 응답: isError=true, "Electron 앱에 연결할 수 없습니다. 앱이 설치되었는지 확인하세요."
```

### 8.3 경계 케이스

#### TC-10: 콘텐츠 크기 정확히 10MB

```
Given: Bridge가 정상 상태
When: open_markdown에 정확히 10MB (10,485,760 bytes) 크기의 content를 전달한다
Then:
  - 검증을 통과한다
  - IPC로 전달되어 정상 수행된다
```

#### TC-11: 콘텐츠 크기 10MB + 1 byte

```
Given: Bridge가 정상 상태
When: open_markdown에 10,485,761 bytes 크기의 content를 전달한다
Then:
  - 로컬 검증에서 즉시 에러 (IPC 전송 없음)
  - MCP 응답: isError=true, "콘텐츠 크기가 10MB를 초과합니다"
```

#### TC-12: MCP 클라이언트 종료 (stdin EOF)

```
Given: Bridge가 실행 중이고 Electron에 연결된 상태, pending 요청 2개 대기 중
When: MCP 클라이언트가 Bridge의 stdin을 닫는다 (프로세스 종료)
Then:
  - stdin 'end' 이벤트 감지
  - pending 요청 2개 완료 대기 (최대 5초)
  - 타임아웃 시 강제 reject
  - IPC 소켓 연결 종료
  - Bridge 프로세스 exit(0)
  - Electron 앱은 계속 실행 (detached)
```

---

## 9. 회귀 테스트 체크리스트

- [ ] `node src/main/mcp-server.mjs` 실행 시 stdout에 MCP 초기화 메시지만 출력, stderr에 `[doclight-mcp] Server started` 로그
- [ ] Electron 실행 상태에서 4개 도구 모두 호출 성공 (open, update, list, close 순서)
- [ ] Electron 미실행 상태에서 도구 호출 시 자동 실행 후 성공
- [ ] Bridge 종료 후 Electron 앱은 계속 실행됨 (detached 확인)

---

## 10. 테스트 코드 템플릿

```javascript
// test/phase3-mcp-bridge.test.js (pseudocode)
//
// 실제 MCP 도구 호출을 시뮬레이션하기 위해
// Bridge의 stdin/stdout을 직접 파이프하여 JSON-RPC 메시지를 교환한다.

import { spawn } from 'node:child_process';
import path from 'node:path';

const PROJECT_ROOT = path.resolve(import.meta.dirname, '..');
const MCP_SERVER = path.join(PROJECT_ROOT, 'src/main/mcp-server.mjs');

function createMcpClient() {
  const proc = spawn('node', [MCP_SERVER], {
    stdio: ['pipe', 'pipe', 'pipe'],
    cwd: PROJECT_ROOT
  });

  let stdoutBuffer = '';
  let responseResolvers = new Map();
  let nextId = 1;

  proc.stdout.on('data', (chunk) => {
    stdoutBuffer += chunk.toString();
    const lines = stdoutBuffer.split('\n');
    stdoutBuffer = lines.pop();
    for (const line of lines) {
      if (!line.trim()) continue;
      const msg = JSON.parse(line);
      const resolver = responseResolvers.get(msg.id);
      if (resolver) {
        responseResolvers.delete(msg.id);
        resolver(msg);
      }
    }
  });

  return {
    async initialize() {
      return this.sendRequest('initialize', {
        protocolVersion: '2024-11-05',
        capabilities: {},
        clientInfo: { name: 'test-client', version: '1.0.0' }
      });
    },

    async callTool(name, args) {
      return this.sendRequest('tools/call', { name, arguments: args });
    },

    async sendRequest(method, params) {
      const id = nextId++;
      return new Promise((resolve, reject) => {
        responseResolvers.set(id, resolve);
        const msg = JSON.stringify({ jsonrpc: '2.0', id, method, params }) + '\n';
        proc.stdin.write(msg);
        setTimeout(() => {
          responseResolvers.delete(id);
          reject(new Error(`Timeout: ${method}`));
        }, 15000);
      });
    },

    close() {
      proc.stdin.end();
      return new Promise(resolve => proc.on('exit', resolve));
    }
  };
}

describe('Phase 3: MCP Bridge', () => {
  let client;

  beforeAll(async () => {
    client = createMcpClient();
    await client.initialize();
  });

  afterAll(async () => {
    // 열린 창 정리
    try { await client.callTool('close_viewer', {}); } catch {}
    await client.close();
  });

  it('open_markdown with content should return windowId', async () => {
    const response = await client.callTool('open_markdown', {
      content: '# MCP Test\n\nBridge test document',
      foreground: true
    });
    expect(response.result).toBeDefined();
    const text = response.result.content[0].text;
    expect(text).toContain('Window ID');
    expect(text).toContain('MCP Test');
  });

  it('list_viewers should show the opened window', async () => {
    const response = await client.callTool('list_viewers', {});
    const text = response.result.content[0].text;
    expect(text).toContain('열린 뷰어: 1개');
    expect(text).toContain('MCP Test');
  });

  it('update_markdown should update existing window', async () => {
    // 먼저 list로 windowId 추출
    const listResp = await client.callTool('list_viewers', {});
    const match = listResp.result.content[0].text.match(/ID: ([a-f0-9-]+)/);
    const windowId = match[1];

    const response = await client.callTool('update_markdown', {
      windowId,
      content: '# Updated Title\n\nNew content here'
    });
    const text = response.result.content[0].text;
    expect(text).toContain('업데이트');
    expect(text).toContain('Updated Title');
  });

  it('close_viewer should close all windows', async () => {
    const response = await client.callTool('close_viewer', {});
    const text = response.result.content[0].text;
    expect(text).toContain('모든 뷰어를 닫았습니다');
  });

  it('open_markdown without content or filePath should return error', async () => {
    const response = await client.callTool('open_markdown', {});
    expect(response.result.isError).toBe(true);
    expect(response.result.content[0].text).toContain('필수');
  });

  it('content exceeding 10MB should be rejected', async () => {
    const bigContent = 'x'.repeat(10 * 1024 * 1024 + 1);
    const response = await client.callTool('open_markdown', { content: bigContent });
    expect(response.result.isError).toBe(true);
    expect(response.result.content[0].text).toContain('10MB');
  });
});
```

---

## 11. 파일 목록 및 예상 코드 크기

| 파일 | 예상 라인 수 | 핵심 책임 |
|------|-------------|-----------|
| `src/main/mcp-server.mjs` | ~300 | MCP 서버 초기화, 4개 도구, IPC 클라이언트, 자동 실행, shutdown |
| **합계** | **~300** | |

**참고**: Phase 2에서 구현한 파일은 수정하지 않는다. `mcp-server.mjs`는 완전히 독립적인 별도 프로세스 진입점이다.

---

## 12. 예상 소요 시간

| 작업 | 소요 시간 |
|------|-----------|
| MCP 서버 초기화 + StdioTransport 연결 | 30분 |
| IPC 소켓 클라이언트 (connect, send, receive, buffer) | 1.5시간 |
| Electron 자동 실행 + 재시도 로직 | 1시간 |
| 4개 MCP 도구 등록 + 입력 검증 | 1.5시간 |
| Graceful shutdown 구현 | 30분 |
| 통합 테스트 (Electron + Bridge 연동) | 2시간 |
| 엣지케이스 + 디버깅 | 1시간 |
| **합계** | **~8시간** |
