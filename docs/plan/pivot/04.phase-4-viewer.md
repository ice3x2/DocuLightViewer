# Phase 4: 마크다운 뷰어 창 구현

## 목표

Markdown 뷰어 렌더러(viewer.html + viewer.js + viewer.css)와 전체 렌더링 파이프라인을 구현한다. marked.parse → DOMPurify.sanitize → DOM 삽입 → mermaid.run → hljs.highlightAll 순서의 파이프라인으로 GitHub-flavored Markdown을 렌더링하고, IPC 채널을 통해 Main Process와 통신한다.

## 선행 조건

- Phase 2 완료 (Electron Main Process — index.js, window-manager.js, preload.js 동작)
- Phase 3 완료 (MCP Bridge — mcp-server.js ↔ IPC Socket 통신 동작)

## 아키텍처 참조

- [00-1.architecture.md](./00-1.architecture.md) Section 2.2 (Renderer Process 컴포넌트), Section 4.1 (MCP open_markdown 시퀀스)

## SRS 참조

- **FR-P-003**: 마크다운 뷰어 창 — 렌더링 파이프라인, BrowserWindow 옵션, 키보드 단축키
- **IR-P-002**: IPC 통신 채널 — render-markdown, update-markdown, window-ready, theme-changed, open-external 채널

---

## 구현 체크리스트

### 4.1 `src/renderer/viewer.html` 생성

- [ ] 파일 생성
- [ ] CSP meta 태그 삽입:
  ```html
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self'">
  ```
- [ ] HTML 레이아웃 구조:
  - `<div id="sidebar-container">` (초기 `display: none`)
    - `<div id="sidebar-tree">` (트리 렌더링 영역)
  - `<div id="resize-handle">` (사이드바 리사이즈 핸들)
  - `<div id="viewer-container">`
    - `<div id="content">` (마크다운 렌더링 영역)
    - `<div id="performance-warning">` (대용량 경고 토스트, 초기 숨김)
- [ ] 라이브러리 스크립트 태그 (순서 중요):
  ```html
  <script src="./lib/marked.min.js"></script>
  <script src="./lib/purify.min.js"></script>
  <script src="./lib/highlight.min.js"></script>
  <script src="./lib/mermaid.min.js"></script>
  <script src="./viewer.js"></script>
  ```
- [ ] 스타일시트 링크:
  ```html
  <link rel="stylesheet" href="./lib/highlight-github.min.css">
  <link rel="stylesheet" href="./viewer.css">
  ```

### 4.2 `src/renderer/viewer.js` 생성

- [ ] 파일 생성
- [ ] **렌더링 파이프라인 함수** `renderMarkdown(markdown)`:
  1. `marked.parse(markdown)` → HTML 변환
  2. `DOMPurify.sanitize(html, { USE_PROFILES: { html: true } })` → XSS 제거
  3. `document.getElementById('content').innerHTML = sanitizedHtml`
  4. `mermaid.run()` → 다이어그램 렌더링 (try-catch per diagram)
  5. `hljs.highlightAll()` → 코드 하이라이팅
- [ ] **`onRenderMarkdown` 핸들러** 등록:
  - `window.doclight.onRenderMarkdown(data)` 콜백
  - `data.markdown`을 렌더링 파이프라인에 전달
  - cleanup 함수를 변수에 저장
- [ ] **`onUpdateMarkdown` 핸들러** 등록:
  - `window.doclight.onUpdateMarkdown(data)` 콜백
  - 동일 렌더링 파이프라인 실행
  - 스크롤 위치 상단 리셋: `document.getElementById('content').scrollTop = 0`
  - cleanup 함수를 변수에 저장
- [ ] **외부 링크 처리**:
  - `document.addEventListener('click', handler)` — 이벤트 위임
  - `<a>` 태그 클릭 감지
  - `href`가 `http://` 또는 `https://`로 시작 → `window.doclight.openExternal(url)`, `e.preventDefault()`
  - `href`가 `.md` 경로 → `window.doclight.navigateTo(path)`, `e.preventDefault()`
  - 기타 프로토콜 (javascript:, data: 등) → `e.preventDefault()` (차단)
- [ ] **키보드 단축키** (document.addEventListener('keydown')):
  - `Ctrl+F` / `Cmd+F`: Electron 내장 findInPage (preload API 필요 없음, 렌더러에서 native 동작)
  - `Ctrl+W` / `Cmd+W`: `window.close()`
  - `Ctrl+=` / `Cmd+=`: zoom in (preload API 또는 webFrame)
  - `Ctrl+-` / `Cmd+-`: zoom out
  - `Ctrl+0` / `Cmd+0`: zoom reset
  - `Ctrl+B` / `Cmd+B`: 사이드바 토글 (Phase 5에서 상세 구현, 여기서는 스텁)
  - `Ctrl+ArrowLeft` / `Alt+ArrowLeft`: `window.doclight.navigateBack()`
  - `Ctrl+ArrowRight` / `Alt+ArrowRight`: `window.doclight.navigateForward()`
  - `Escape`: always-on-top 해제 (별도 IPC 채널 필요 시 Phase 6에서 추가)
- [ ] **window-ready 알림**: `DOMContentLoaded` 이벤트에서 `window.doclight.notifyReady()` 호출
- [ ] **메모리 누수 방지**: `beforeunload` 이벤트에서 모든 `on*` cleanup 함수 호출
  ```javascript
  const cleanups = [];
  cleanups.push(window.doclight.onRenderMarkdown(renderHandler));
  cleanups.push(window.doclight.onUpdateMarkdown(updateHandler));
  // Phase 5에서 추가: cleanups.push(window.doclight.onSidebarTree(sidebarHandler));
  window.addEventListener('beforeunload', () => cleanups.forEach(fn => fn()));
  ```

### 4.3 `src/renderer/viewer.css` 생성

- [ ] 파일 생성
- [ ] **GitHub-flavored Markdown 스타일**:
  - `body`: `font-family: var(--font-family); font-size: var(--font-size); line-height: 1.6; color: var(--text-color); background: var(--bg-color); padding: 2rem; max-width: 900px; margin: 0 auto;`
  - `h1` ~ `h6`: 각 레벨별 크기, 하단 border (h1, h2), `margin-top: 1.5em`
  - `p`: `margin: 1em 0`
  - `code` (인라인): `background: var(--code-bg); padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.9em`
  - `pre > code`: `display: block; padding: 1em; overflow-x: auto; border-radius: 6px`
  - `blockquote`: `border-left: 4px solid var(--border-color); padding-left: 1em; color: var(--muted-text); margin: 1em 0`
  - `table`: `border-collapse: collapse; width: 100%`, `th, td`: `border: 1px solid var(--border-color); padding: 8px 12px`
  - `img`: `max-width: 100%; height: auto`
  - `hr`: `border: none; border-top: 2px solid var(--border-color); margin: 2em 0`
  - `ul, ol`: `padding-left: 2em; margin: 1em 0`
  - `li`: `margin: 0.25em 0`
  - `a`: `color: var(--link-color); text-decoration: none`, hover: `text-decoration: underline`
- [ ] **사이드바 레이아웃** (Phase 5에서 활성화, 여기서는 구조만):
  - 전체 레이아웃: `display: flex; height: 100vh`
  - `#sidebar-container`: `width: 260px; min-width: 150px; overflow-y: auto; border-right: 1px solid var(--border-color); flex-shrink: 0`
  - `#resize-handle`: `width: 4px; cursor: col-resize; background: transparent; flex-shrink: 0`
  - `#viewer-container`: `flex: 1; overflow-y: auto`
  - 사이드바 숨김 상태: `#sidebar-container.hidden { display: none }`, `#resize-handle.hidden { display: none }`, `#viewer-container { width: 100% }`
  - 사이드바 토글 애니메이션: `#sidebar-container { transition: width 200ms ease }`
- [ ] **Light 테마 CSS 변수** (`:root`):
  ```css
  --bg-color: #ffffff;
  --text-color: #24292e;
  --muted-text: #6a737d;
  --border-color: #e1e4e8;
  --code-bg: #f6f8fa;
  --link-color: #0366d6;
  --font-family: system-ui, -apple-system, sans-serif;
  --font-size: 16px;
  --sidebar-bg: #f6f8fa;
  --sidebar-hover: #e1e4e8;
  --highlight-bg: #e8f0fe;
  ```
- [ ] **Dark 테마 CSS 변수** (`[data-theme="dark"]`):
  ```css
  --bg-color: #0d1117;
  --text-color: #c9d1d9;
  --muted-text: #8b949e;
  --border-color: #30363d;
  --code-bg: #161b22;
  --link-color: #58a6ff;
  --sidebar-bg: #161b22;
  --sidebar-hover: #30363d;
  --highlight-bg: #1f2937;
  ```
- [ ] **Mermaid 다이어그램 스타일**:
  - `.mermaid`: `text-align: center; margin: 1em 0`
  - `.mermaid-error`: `color: var(--muted-text); background: var(--code-bg); padding: 1em; border-radius: 6px; font-style: italic`
- [ ] **코드 블록 스타일**: highlight.js 테마 파일(`highlight-github.min.css`) + 커스텀 오버라이드
- [ ] **성능 경고 토스트**:
  ```css
  #performance-warning {
    position: fixed; bottom: 20px; right: 20px;
    background: var(--border-color); padding: 12px 20px;
    border-radius: 8px; display: none; z-index: 1000;
    animation: fadeIn 300ms ease;
  }
  ```
- [ ] **Responsive 고려**: `min-width: 400px` (BrowserWindow minWidth와 동일)

### 4.4 라이브러리 파일 배치 (`src/renderer/lib/`)

- [ ] `src/renderer/lib/` 디렉토리 생성
- [ ] `marked.min.js` 복사 (npm 패키지에서 dist 또는 직접 다운로드)
- [ ] `purify.min.js` 복사 (DOMPurify dist)
- [ ] `highlight.min.js` 복사 (highlight.js CDN/dist)
- [ ] `highlight-github.min.css` 복사 (highlight.js GitHub 테마)
- [ ] `mermaid.min.js` 복사 (mermaid dist)
- [ ] 각 라이브러리 버전을 `src/renderer/lib/VERSION.md`에 기록 (추적용)

> **중복 방지 주의**: `marked`는 Main Process(link-parser.js)에서도 `marked.lexer()`로 사용한다. Main은 `require('marked')`(npm), Renderer는 `<script src="./lib/marked.min.js">`(로컬 번들). 동일 패키지를 두 가지 방식으로 로드하는 것은 의도적 설계이다 (sandbox 렌더러에서 require 불가). `src/renderer/lib/`와 `node_modules/marked`는 별도 관리하며, npm의 marked를 lib/에 복사하는 빌드 스크립트가 없으면 수동 관리한다.

### 4.5 Window Manager → Renderer IPC 연결

- [ ] `window-manager.js`에서 `window-ready` IPC 수신 핸들러 구현:
  - `ipcMain.on('window-ready', (event) => { ... })` 또는 per-window 리스너
  - `event.sender`로부터 `BrowserWindow.fromWebContents(event.sender)`로 창 식별
  - 해당 창의 meta에서 markdown, filePath 조회
  - `win.webContents.send('render-markdown', { markdown, filePath, windowId })` 전송
- [ ] `theme-changed` 브로드캐스트 구현:
  - 설정 변경 시 모든 열린 뷰어 창에 `win.webContents.send('theme-changed', settings)` 전송
  - `viewer.js`에서 `onThemeChanged` 핸들러: `document.documentElement.dataset.theme = data.theme` + CSS 변수 업데이트
- [ ] `open-external` IPC 핸들러 (index.js 또는 window-manager.js):
  - `ipcMain.on('open-external', (event, { url }) => { ... })`
  - URL 프로토콜 검증: `http:` 또는 `https:`만 허용
  - `shell.openExternal(url)` 호출
  - 불허 프로토콜 (`javascript:`, `vbscript:`, `file:`, `data:`) → 무시 + stderr 경고 로그

### 4.6 Mermaid 에러 처리

- [ ] `mermaid.initialize({ startOnLoad: false, securityLevel: 'strict' })` 호출 (DOMContentLoaded)
- [ ] 렌더링 시 각 `.language-mermaid` 코드 블록을 개별 try-catch로 감싸기:
  ```javascript
  const mermaidBlocks = document.querySelectorAll('code.language-mermaid');
  for (const block of mermaidBlocks) {
    try {
      const container = block.parentElement;
      const { svg } = await mermaid.render(`mermaid-${idx}`, block.textContent);
      container.outerHTML = `<div class="mermaid">${svg}</div>`;
    } catch (err) {
      block.parentElement.outerHTML =
        `<div class="mermaid-error">Mermaid 렌더링 오류: ${err.message}</div>`;
    }
  }
  ```
- [ ] 에러 블록에 원본 코드를 토글로 볼 수 있는 `<details>` 포함 (선택사항)

### 4.7 대용량 문서 경고

- [ ] `renderMarkdown()` 진입 시 `markdown.length` 체크
- [ ] 5MB (5,242,880 bytes) 초과 시:
  - `#performance-warning` 요소 `display: block` 설정
  - 메시지: "이 문서는 매우 큽니다 (${(size/1024/1024).toFixed(1)}MB). 렌더링에 시간이 걸릴 수 있습니다."
  - 3초 후 자동 숨김 (setTimeout)
- [ ] 경고 표시 후에도 렌더링은 계속 진행

---

## 제거 대상 코드 (Dead/Unnecessary Code)

이 Phase 구현 시 다음 기존 파일들은 Electron 전환으로 인해 **완전히 불필요**하며, 피봇 완료 시 제거해야 한다:

| 파일 경로 | 제거 사유 |
|-----------|----------|
| `public/js/app.js` | Express 웹 클라이언트 코드. Electron renderer의 viewer.js로 대체 |
| `public/js/doclight-utils.js` | Express 웹 유틸리티. 신규 아키텍처에서 불필요 |
| `public/js/chatbot.js` | 챗봇 UI. 피봇 범위에서 완전 제거 |
| `public/js/admin.js` | 어드민 패널 UI. 피봇 범위에서 완전 제거 |
| `public/css/style.css` | Express 웹 스타일. viewer.css로 대체 |
| `public/css/chatbot.css` | 챗봇 스타일. 피봇 범위에서 완전 제거 |
| `public/css/admin.css` | 어드민 스타일. 피봇 범위에서 완전 제거 |
| `src/views/*.ejs` | EJS 템플릿 전체. Electron에서 viewer.html 단일 파일로 대체 |
| `src/middleware/error-handler.js` | Express 에러 핸들러. Electron에서 IPC 에러 처리로 대체 |
| `src/middleware/request-logger.js` | HTTP 요청 로깅. Electron에서 불필요 |
| `src/utils/logger.js` | Winston 로거. Electron에서는 stderr 로깅으로 단순화 |
| `src/services/markdown-renderer.js` | 서버 사이드 마크다운 렌더링. 렌더러에서 클라이언트 사이드로 이동 |

> **주의**: 위 파일들은 Phase 4 구현 시 직접 삭제하지 않는다. 모든 Phase 완료 후 일괄 정리한다.

---

## 테스트 시나리오

### 정상 케이스

**TC-4-01: 기본 마크다운 렌더링**

```
Given: 뷰어 창이 열리고 content="# Hello\nWorld" 데이터가 render-markdown IPC로 전달된 상태
When: 렌더링 파이프라인이 실행된다
Then: H1 요소에 "Hello" 텍스트가 표시되고, p 요소에 "World" 텍스트가 표시된다
  And: hljs.highlightAll()이 호출되어 코드 블록이 없더라도 에러 없이 완료된다
```

**TC-4-02: Mermaid 다이어그램 렌더링**

```
Given: 뷰어 창이 열리고 content에 아래 Mermaid 코드 블록이 포함된 상태:
  ```mermaid
  graph TD
    A --> B
  ```
When: 렌더링 파이프라인이 실행된다
Then: 코드 블록 대신 SVG 다이어그램이 렌더링되어 A → B 노드가 시각적으로 표시된다
  And: SVG 요소가 .mermaid 클래스 컨테이너 안에 있다
```

### 예외 케이스

**TC-4-03: 잘못된 Mermaid 구문**

```
Given: 뷰어 창이 열리고 content에 유효하지 않은 Mermaid 구문이 포함된 상태:
  ```mermaid
  invalid syntax here %%%
  ```
When: 렌더링 파이프라인이 실행된다
Then: 해당 블록 위치에 "Mermaid 렌더링 오류: ..." 에러 메시지가 표시된다
  And: 나머지 문서 내용은 정상적으로 렌더링된다
  And: 전체 렌더링 프로세스가 중단되지 않는다
```

**TC-4-04: XSS 공격 시도 (DOMPurify 검증)**

```
Given: 뷰어 창이 열리고 content="<script>alert('xss')</script><p>Safe</p><img onerror='alert(1)' src='x'>" 데이터가 전달된 상태
When: 렌더링 파이프라인의 DOMPurify.sanitize() 단계가 실행된다
Then: <script> 태그가 완전히 제거되고, <img>의 onerror 속성이 제거된다
  And: <p>Safe</p>는 정상적으로 렌더링된다
  And: DOM에 실행 가능한 스크립트가 존재하지 않는다
```

### 경계값 테스트

**TC-4-05: 대용량 문서 (5MB 초과)**

```
Given: 뷰어 창이 열리고 5.5MB 크기의 Markdown content가 전달된 상태
When: renderMarkdown() 함수가 호출된다
Then: 성능 경고 토스트가 화면 우하단에 "이 문서는 매우 큽니다 (5.5MB)" 메시지와 함께 표시된다
  And: 경고에도 불구하고 렌더링이 완료되어 문서 내용이 표시된다
  And: 3초 후 경고 토스트가 자동으로 숨겨진다
```

---

## 회귀 테스트 체크리스트

- [ ] Phase 2 확인: Electron 앱 실행 시 트레이 아이콘 표시 + IPC 소켓 서버 리스닝 정상
- [ ] Phase 3 확인: MCP Bridge에서 open_markdown 호출 시 IPC 소켓으로 요청 전달 + 응답 수신 정상
- [ ] Phase 2 확인: window-manager.js의 createWindow()가 BrowserWindow 생성 후 Map에 정상 등록
- [ ] Phase 3 확인: close_viewer 호출 시 창 닫힘 + Map에서 제거 정상

---

## 테스트 코드 템플릿

```javascript
// test/renderer/viewer.test.js (pseudocode — Playwright 또는 Electron spectron 기반)

const { _electron: electron } = require('playwright');

describe('Viewer Rendering Pipeline', () => {
  let app;
  let window;

  beforeAll(async () => {
    app = await electron.launch({ args: ['src/main/index.js'] });
    // MCP 또는 직접 IPC로 open_markdown 호출
  });

  afterAll(async () => {
    await app.close();
  });

  describe('TC-4-01: 기본 마크다운 렌더링', () => {
    it('should render H1 and paragraph from markdown content', async () => {
      // Given: open_markdown with content="# Hello\nWorld"
      // (IPC 소켓 또는 내부 API로 창 생성)

      // When: 렌더링 완료 대기
      const page = await app.firstWindow();
      await page.waitForSelector('#content h1');

      // Then: H1 "Hello"와 p "World" 확인
      const h1Text = await page.textContent('#content h1');
      const pText = await page.textContent('#content p');
      expect(h1Text).toBe('Hello');
      expect(pText).toBe('World');
    });
  });

  describe('TC-4-04: XSS 방지', () => {
    it('should sanitize script tags and event handlers', async () => {
      // Given: content with <script> and onerror
      // When: 렌더링 완료
      const page = await app.firstWindow();

      // Then: script 태그 부재 확인
      const scripts = await page.$$('#content script');
      expect(scripts.length).toBe(0);

      // Then: onerror 속성 부재 확인
      const imgs = await page.$$('#content img[onerror]');
      expect(imgs.length).toBe(0);

      // Then: 안전한 콘텐츠는 존재
      const safeText = await page.textContent('#content p');
      expect(safeText).toBe('Safe');
    });
  });

  describe('TC-4-05: 대용량 문서 경고', () => {
    it('should show performance warning for 5MB+ documents', async () => {
      // Given: 5.5MB content
      const largeContent = '# Title\n' + 'x'.repeat(5.5 * 1024 * 1024);
      // (open_markdown with largeContent)

      const page = await app.firstWindow();

      // Then: 경고 토스트 표시 확인
      const warning = await page.waitForSelector('#performance-warning',
        { state: 'visible', timeout: 5000 });
      expect(warning).toBeTruthy();

      // Then: 3초 후 숨겨짐 확인
      await page.waitForSelector('#performance-warning',
        { state: 'hidden', timeout: 5000 });
    });
  });
});
```

---

## 구현 순서

1. `src/renderer/lib/` 디렉토리 생성 + 라이브러리 파일 배치 (4.4)
2. `viewer.html` 생성 — 레이아웃 + CSP + 스크립트 태그 (4.1)
3. `viewer.css` 생성 — GitHub-flavored 스타일 + 테마 변수 (4.3)
4. `viewer.js` 생성 — 렌더링 파이프라인 + IPC 핸들러 (4.2)
5. Window Manager IPC 연결 — window-ready → render-markdown 흐름 (4.5)
6. Mermaid 에러 처리 추가 (4.6)
7. 대용량 문서 경고 추가 (4.7)
8. 통합 테스트 (MCP open_markdown → 뷰어 렌더링 E2E)

---

## 예상 파일 구조

```
src/renderer/
├── viewer.html              # 뷰어 페이지 (사이드바 + 본문)
├── viewer.js                # 렌더링 로직 + IPC 핸들러 + 키보드 단축키
├── viewer.css               # GitHub-flavored MD 스타일 + Light/Dark 테마
└── lib/                     # 클라이언트 라이브러리 (로컬 번들)
    ├── marked.min.js
    ├── purify.min.js
    ├── highlight.min.js
    ├── highlight-github.min.css
    ├── mermaid.min.js
    └── VERSION.md           # 라이브러리 버전 기록
```

---

## 완료 기준

- [ ] viewer.html이 BrowserWindow에서 정상 로드됨
- [ ] marked → DOMPurify → DOM → mermaid → hljs 파이프라인 정상 동작
- [ ] XSS 공격 벡터가 DOMPurify에 의해 차단됨
- [ ] Mermaid 에러가 개별 블록 단위로 처리되고 전체 렌더링을 중단하지 않음
- [ ] 외부 링크 클릭 시 시스템 브라우저에서 열림 (http/https만)
- [ ] 5MB 초과 문서에 성능 경고 표시
- [ ] window-ready → render-markdown IPC 흐름 정상
- [ ] beforeunload에서 모든 리스너 정리됨
