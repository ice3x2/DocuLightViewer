# Phase 2: Electron Main Process 구현

작성일: 2026-02-14
최종 업데이트: 2026-02-14

## 한 줄 요약

Electron 앱 진입점, 시스템 트레이, IPC 소켓 서버, Window Manager, Preload API를 구현하여 MCP Bridge가 연결할 수 있는 GUI 인프라를 완성한다.

---

## 1. 목표

Electron 앱의 핵심 Main Process를 구현한다:
- 싱글 인스턴스 락으로 중복 실행 방지
- 시스템 트레이 상주 (창이 없어도 유지)
- Named Pipe / Unix Socket 기반 IPC 소켓 서버
- ndjson 프레이밍 프로토콜 처리
- BrowserWindow 생성/관리/네비게이션 (Window Manager)
- contextBridge 기반 Preload API 노출

Phase 2 완료 후, MCP Bridge 없이도 IPC 소켓에 직접 ndjson 메시지를 보내 창을 열고 닫을 수 있어야 한다.

## 2. 선행 조건

- Phase 1 완료 (클린 프로젝트 상태)
- `npm install` 완료 (electron, electron-store, uuid, marked 설치됨)

## 3. 아키텍처 참조

- `00-1.architecture.md` Section 2.1 (Main Process 컴포넌트)
- `00-1.architecture.md` Section 3.1 (Window Manager 클래스)
- `00-1.architecture.md` Section 4.1 (시퀀스 다이어그램)
- `00-1.architecture.md` Section 5.1 (인메모리 데이터), Section 5.2 (영구 데이터)
- `00-1.architecture.md` Section 5.3 (IPC 소켓 메시지 포맷)
- `00-2.tech-decisions.md` ADR-002 (분리 아키텍처), ADR-003 (Named Pipe / Unix Socket)

---

## 4. 구현 체크리스트

### 4.1 `src/main/index.js` — 앱 진입점 + IPC 소켓 서버

#### 앱 생명주기

- [ ] `app.requestSingleInstanceLock()` 호출: 실패 시 `app.quit()`, 성공 시 `second-instance` 이벤트에서 기존 창 포커스
- [ ] `app.on('ready')` 핸들러:
  1. 스테일 소켓 파일 정리 (`cleanupStaleSocket()`)
  2. 시스템 트레이 생성 (`createTray()`)
  3. IPC 소켓 서버 시작 (`startIpcServer()`)
- [ ] `app.on('window-all-closed')`: `e.preventDefault()` — 트레이 모드 유지, quit하지 않음
- [ ] `app.on('before-quit')`:
  1. 모든 BrowserWindow 닫기 (`windowManager.closeWindow()`)
  2. IPC 소켓 서버 종료 (`server.close()`)
  3. 소켓 파일 정리 (Unix)

#### 시스템 트레이

- [ ] `Tray` 생성: `assets/icon.png` 아이콘 사용
- [ ] 툴팁: "DocLight"
- [ ] 컨텍스트 메뉴 구성:
  ```
  - 창 #1 제목 (최대 30자, click → focus)
  - 창 #2 제목
  - ...최대 10개
  - (10개 초과 시) "외 N개..."
  - ─── 구분선 ───
  - 모든 창 닫기
  - ─── 구분선 ───
  - DocLight 종료
  ```
- [ ] `updateTrayMenu()` 함수: WindowManager의 창 목록 변경 시마다 호출
- [ ] 트레이 메뉴 항목 클릭 시 해당 창 `win.focus()` + `win.show()`

#### IPC 소켓 서버

- [ ] 소켓 경로 상수 정의:
  ```javascript
  const PIPE_PATH = process.platform === 'win32'
    ? '\\\\.\\pipe\\doclight-ipc'
    : '/tmp/doclight-ipc.sock';
  ```
- [ ] `cleanupStaleSocket()` 함수:
  - Unix만 해당: 소켓 파일 존재 시 `net.connect()` 시도
  - `ECONNREFUSED` → 스테일 파일, `fs.unlinkSync()` 삭제
  - 연결 성공 → 다른 인스턴스 실행 중, 에러 로그 후 현재 인스턴스 종료
- [ ] `net.createServer()` 생성, `server.listen(PIPE_PATH)` 바인딩
- [ ] Unix 소켓 퍼미션: `fs.chmodSync(PIPE_PATH, 0o600)` (소유자만 접근)
- [ ] 연결 당 버퍼 관리: `let buffer = ''`
- [ ] `connection.on('data')` 핸들러:
  1. `buffer += chunk.toString()`
  2. `buffer.split('\n')` 으로 완성된 줄 추출
  3. 마지막 불완전 줄은 buffer에 유지
  4. 각 완성된 줄: `JSON.parse()` → 요청 라우팅
- [ ] 요청 라우팅 로직:
  ```javascript
  async function handleRequest(request, connection) {
    const { id, action, params } = request;
    try {
      let result;
      switch (action) {
        case 'open_markdown':    result = await windowManager.createWindow(params); break;
        case 'update_markdown':  result = await windowManager.updateWindow(params.windowId, params); break;
        case 'close_viewer':     result = windowManager.closeWindow(params?.windowId); break;
        case 'list_viewers':     result = { windows: windowManager.listWindows() }; break;
        default: throw new Error(`Unknown action: ${action}`);
      }
      connection.write(JSON.stringify({ id, result }) + '\n');
    } catch (err) {
      connection.write(JSON.stringify({ id, error: { message: err.message } }) + '\n');
    }
  }
  ```
- [ ] `connection.on('error')`: 로그만 출력, 서버는 계속 동작
- [ ] `connection.on('close')`: 연결별 buffer 정리

### 4.2 `src/main/preload.js` — contextBridge API

- [ ] `contextBridge.exposeInMainWorld('doclight', { ... })` 구현
- [ ] 리스너 채널 (Main → Renderer):
  ```javascript
  onRenderMarkdown: (callback) => {
    const handler = (_event, data) => callback(data);
    ipcRenderer.on('render-markdown', handler);
    return () => ipcRenderer.removeListener('render-markdown', handler);
  },
  onUpdateMarkdown: (callback) => {
    const handler = (_event, data) => callback(data);
    ipcRenderer.on('update-markdown', handler);
    return () => ipcRenderer.removeListener('update-markdown', handler);
  },
  onSidebarTree: (callback) => {
    const handler = (_event, data) => callback(data);
    ipcRenderer.on('sidebar-tree', handler);
    return () => ipcRenderer.removeListener('sidebar-tree', handler);
  }
  ```
- [ ] 발신 채널 (Renderer → Main):
  ```javascript
  navigateTo: (filePath) => ipcRenderer.send('navigate-to', filePath),
  navigateBack: () => ipcRenderer.send('navigate-back'),
  navigateForward: () => ipcRenderer.send('navigate-forward'),
  openExternal: (url) => ipcRenderer.send('open-external', url),
  notifyReady: () => ipcRenderer.send('window-ready')
  ```
- [ ] 리스너에 cleanup 함수 반환 (메모리 누수 방지)

### 4.3 `src/main/window-manager.js` — 창 관리 + 네비게이션

#### WindowManager 클래스

- [ ] 내부 상태:
  ```javascript
  this.windows = new Map();    // Map<string, { win: BrowserWindow, meta: WindowMeta }>
  this.lastPosition = { x: 0, y: 0 };
  this.store = new ElectronStore({ ... });
  ```
- [ ] `electron-store` 스키마 정의:
  ```javascript
  {
    defaultWindowWidth:  { type: 'number', default: 1000 },
    defaultWindowHeight: { type: 'number', default: 750 },
    sidebarWidth:        { type: 'number', default: 260 },
    theme:               { type: 'string', default: 'light' },
    fontSize:            { type: 'number', default: 16 },
    maxRecursionDepth:   { type: 'number', default: 10 }
  }
  ```

#### createWindow(opts)

- [ ] 매개변수: `{ content?, filePath?, foreground?, title?, size? }`
- [ ] `content`와 `filePath` 중 하나 필수 검증
- [ ] `filePath` 제공 시: `fs.readFile()` + `.md` 확장자 검증
- [ ] 최대 창 수 검사: `this.windows.size >= 20` 이면 에러
- [ ] UUID v4로 `windowId` 생성
- [ ] `resolveWindowSize(size)` 호출로 창 크기 결정
- [ ] `getNextPosition()` 호출로 캐스케이딩 위치 계산
- [ ] BrowserWindow 생성:
  ```javascript
  const { width, height } = this.resolveWindowSize(opts.size);
  const win = new BrowserWindow({
    width, height,
    x: pos.x, y: pos.y,
    title: title || extractTitle(content || fileContent),
    icon: path.join(__dirname, '../../assets/icon.png'),
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: true
    }
  });
  // size === 'f'이면 win.maximize()
  if (opts.size === 'f') win.maximize();
  ```

#### resolveWindowSize(size)

- [ ] 창 크기 프리셋 상수 정의:
  ```javascript
  const SIZE_PRESETS = {
    s: { width: 480,  height: 680  },
    m: { width: 720,  height: 1024 },
    l: { width: 1080, height: 1440 },
    f: 'fullscreen'  // maximize 처리
  };
  ```
- [ ] `size` 미지정 또는 유효하지 않으면 기본값 `'m'`
- [ ] `size === 'f'`이면 주 모니터(인덱스 0) 작업 영역 크기 반환:
  ```javascript
  const primaryDisplay = require('electron').screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;
  return { width, height };
  ```
- [ ] 프리셋 값을 화면 크기로 클램핑:
  ```javascript
  const primaryDisplay = require('electron').screen.getPrimaryDisplay();
  const { width: screenW, height: screenH } = primaryDisplay.workAreaSize;
  const preset = SIZE_PRESETS[size] || SIZE_PRESETS.m;
  return {
    width:  Math.min(preset.width, screenW),
    height: Math.min(preset.height, screenH)
  };
  ```
- [ ] 다중 모니터: `screen.getPrimaryDisplay()` 사용 (항상 가장 앞 인덱스 모니터에 출력)
- [ ] `win.loadFile('src/renderer/viewer.html')` 호출
- [ ] `window-ready` IPC 수신 대기 (Renderer가 `notifyReady()` 호출 시)
- [ ] Ready 후 `render-markdown` IPC 전송: `{ content, filePath, title }`
- [ ] `filePath` 존재 시 사이드바 트리 빌드: `linkParser.buildLinkTree(filePath)` → `sidebar-tree` IPC 전송
- [ ] NavigationHistory 초기화: `filePath` push
- [ ] `win.on('closed')`: Map에서 제거, 트레이 메뉴 업데이트
- [ ] Map에 저장: `{ win, meta: { windowId, filePath, title, alwaysOnTop: false, history } }`
- [ ] `foreground` 옵션: true이면 `win.focus()`, false이면 그대로
- [ ] 트레이 메뉴 업데이트 콜백 호출
- [ ] 반환: `{ windowId, title }`

#### closeWindow(windowId?)

- [ ] `windowId` 미제공: 모든 창 닫기
- [ ] `windowId` 제공: 해당 창만 닫기
- [ ] 존재하지 않는 `windowId`: 에러 throw
- [ ] 반환: `{ closed: number }` (닫힌 창 수)

#### updateWindow(windowId, opts)

- [ ] `opts`: `{ content?, filePath?, title? }`
- [ ] 존재하지 않는 `windowId`: 에러 throw
- [ ] `filePath` 제공 시: `fs.readFile()` + `.md` 확장자 검증
- [ ] `update-markdown` IPC 전송: `{ content, filePath, title }`
- [ ] `meta.title` 업데이트, `win.setTitle()` 호출
- [ ] 반환: `{ title }`

#### listWindows()

- [ ] Map 순회, 각 창의 `{ windowId, title, alwaysOnTop }` 배열 반환

#### navigateTo(windowId, filePath)

- [ ] 파일 읽기: `fs.readFile(filePath, 'utf-8')`
- [ ] NavigationHistory에 push
- [ ] `render-markdown` IPC 전송
- [ ] 사이드바 하이라이트 업데이트 (트리 재빌드 하지 않음, ADR-005)
- [ ] `meta.filePath` 업데이트

#### navigateBack(windowId) / navigateForward(windowId)

- [ ] NavigationHistory에서 `back()` / `forward()` 호출
- [ ] null 반환 시 무시 (더 이상 이동 불가)
- [ ] 유효한 경로 반환 시 `navigateTo()` 호출

#### getNextPosition()

- [ ] 첫 창: 화면 중앙
- [ ] 이후: 이전 위치에서 x+30, y+30
- [ ] 화면 밖으로 나가면 (0, 0)으로 wrap-around
- [ ] `screen.getPrimaryDisplay().workAreaSize` 사용

#### NavigationHistory 클래스

- [ ] `MAX_SIZE = 50`
- [ ] `stack: string[]` (filePath 배열)
- [ ] `index: number` (현재 위치, -1 초기값)
- [ ] `push(filePath)`:
  - 현재 위치 이후의 forward 히스토리 제거 (`stack.splice(index + 1)`)
  - push, index++
  - `MAX_SIZE` 초과 시 가장 오래된 것 shift
- [ ] `back()`: `index > 0`이면 index--, `stack[index]` 반환; 아니면 null
- [ ] `forward()`: `index < stack.length - 1`이면 index++, `stack[index]` 반환; 아니면 null

### 4.4 IPC 수신 핸들러 등록 (index.js 내)

- [ ] `ipcMain.on('navigate-to', (event, filePath) => { ... })`:
  - `BrowserWindow.fromWebContents(event.sender)` 로 창 식별
  - `windowManager.navigateTo(windowId, filePath)` 호출
- [ ] `ipcMain.on('navigate-back', (event) => { ... })`:
  - 창 식별 → `windowManager.navigateBack(windowId)`
- [ ] `ipcMain.on('navigate-forward', (event) => { ... })`:
  - 창 식별 → `windowManager.navigateForward(windowId)`
- [ ] `ipcMain.on('open-external', (event, url) => { ... })`:
  - `shell.openExternal(url)` (브라우저에서 URL 열기)
- [ ] `ipcMain.on('window-ready', (event) => { ... })`:
  - 창 식별 → 대기 중인 render-markdown 전송 resolve

---

## 5. IPC 소켓 메시지 프로토콜

### 5.1 요청 (Bridge → Electron)

```json
{ "id": "550e8400-e29b-41d4-a716-446655440000", "action": "open_markdown", "params": { "content": "# Hello", "foreground": true } }
```

### 5.2 성공 응답 (Electron → Bridge)

```json
{ "id": "550e8400-e29b-41d4-a716-446655440000", "result": { "windowId": "6ba7b810-9dad-11d1-80b4-00c04fd430c8", "title": "Hello" } }
```

### 5.3 에러 응답 (Electron → Bridge)

```json
{ "id": "550e8400-e29b-41d4-a716-446655440000", "error": { "message": "Maximum window limit (20) reached" } }
```

---

## 6. 보안 고려사항

| 영역 | 조치 |
|------|------|
| 렌더러 격리 | `contextIsolation: true`, `nodeIntegration: false`, `sandbox: true` |
| Preload API | `contextBridge` 사용, 최소 필요 채널만 노출 |
| IPC 소켓 | Unix: `0o600` 퍼미션 (소유자만), Windows: Named Pipe (기본적으로 현재 사용자 세션 격리) |
| 외부 링크 | `shell.openExternal()` 사용, Renderer에서 직접 navigate하지 않음 |
| 파일 접근 | `filePath`는 `.md` 확장자 검증, 존재 확인만 수행 |

---

## 7. 테스트 시나리오

### 7.1 정상 케이스

#### TC-1: 앱 시작 시 트레이 + 소켓 서버

```
Given: Phase 1이 완료되고 index.js가 구현된 상태
When: npx electron .을 실행한다
Then:
  - 시스템 트레이에 DocLight 아이콘이 표시된다
  - IPC 소켓 서버가 PIPE_PATH에 리스닝 중이다
  - Windows: \\.\pipe\doclight-ipc 파이프가 존재한다
  - 트레이 컨텍스트 메뉴에 "DocLight 종료" 항목이 있다
```

#### TC-2: 싱글 인스턴스 락

```
Given: DocLight Electron 앱이 이미 실행 중인 상태
When: 동일한 npx electron .을 두 번째 실행한다
Then:
  - 두 번째 인스턴스가 즉시 종료된다 (requestSingleInstanceLock 실패)
  - 첫 번째 인스턴스의 기존 창이 있으면 포커스된다
  - 소켓 서버가 중복 생성되지 않는다
```

#### TC-3: IPC 소켓으로 창 열기

```
Given: DocLight 앱이 실행 중이고 소켓 서버가 리스닝 상태
When: 소켓에 다음 ndjson 메시지를 전송한다:
  {"id":"test-1","action":"open_markdown","params":{"content":"# Test Doc\n\nHello World","foreground":true}}
Then:
  - 새 BrowserWindow가 생성된다
  - 응답 메시지가 수신된다: {"id":"test-1","result":{"windowId":"<uuid>","title":"Test Doc"}}
  - 트레이 컨텍스트 메뉴에 "Test Doc" 항목이 추가된다
  - 창이 foreground로 표시된다
```

#### TC-4: 창 목록 조회

```
Given: DocLight에 2개 창이 열린 상태 (창A: "Doc 1", 창B: "Doc 2")
When: 소켓에 {"id":"test-2","action":"list_viewers","params":{}} 전송
Then:
  - 응답: {"id":"test-2","result":{"windows":[{"windowId":"...","title":"Doc 1","alwaysOnTop":false},{"windowId":"...","title":"Doc 2","alwaysOnTop":false}]}}
```

#### TC-5: 특정 창 닫기

```
Given: 창A (windowId: "abc-123")가 열린 상태
When: 소켓에 {"id":"test-3","action":"close_viewer","params":{"windowId":"abc-123"}} 전송
Then:
  - 창A가 닫힌다
  - 응답: {"id":"test-3","result":{"closed":1}}
  - 트레이 메뉴에서 창A 항목이 제거된다
  - 앱은 종료되지 않는다 (트레이 모드 유지)
```

### 7.2 예외 케이스

#### TC-6: 스테일 소켓 파일 정리

```
Given: /tmp/doclight-ipc.sock 파일이 존재하지만 연결할 수 없는 상태 (Unix)
When: DocLight 앱을 시작한다
Then:
  - 스테일 소켓 파일이 삭제된다
  - 새 소켓 서버가 정상적으로 생성된다
  - 에러 없이 앱이 시작된다
```

#### TC-7: 소켓 연결 드랍

```
Given: Bridge가 소켓에 연결된 상태
When: Bridge 프로세스가 비정상 종료된다 (SIGKILL)
Then:
  - connection 'error' 이벤트 발생, 에러 로그만 출력
  - IPC 소켓 서버는 계속 동작한다
  - 다른 클라이언트의 연결이 가능하다
  - 기존 열린 창은 영향 없이 유지된다
```

#### TC-8: 존재하지 않는 windowId 조작

```
Given: DocLight에 창이 0개인 상태
When: 소켓에 {"id":"test-4","action":"close_viewer","params":{"windowId":"nonexistent"}} 전송
Then:
  - 에러 응답: {"id":"test-4","error":{"message":"Window not found: nonexistent"}}
```

### 7.3 경계 케이스

#### TC-9: 트레이 메뉴 최대 창 표시

```
Given: DocLight에 20개 창이 열린 상태 (최대치)
When: 트레이 아이콘을 우클릭하여 컨텍스트 메뉴를 연다
Then:
  - 처음 10개 창의 제목이 메뉴 항목으로 표시된다
  - 11번째 항목으로 "외 10개..." 텍스트가 표시된다 (클릭 불가)
  - 구분선 후 "모든 창 닫기", "DocLight 종료" 항목이 있다
```

#### TC-10: NavigationHistory 최대 크기

```
Given: 하나의 창에서 NavigationHistory의 MAX_SIZE(50)만큼 네비게이션한 상태
When: 51번째 문서로 네비게이션한다
Then:
  - 가장 오래된 히스토리 항목이 제거된다
  - 히스토리 크기는 50을 유지한다
  - back() 호출 시 49번째 문서로 이동 가능하다
```

#### TC-11: 창 최대 수 초과 시도

```
Given: 이미 20개 창이 열린 상태
When: 소켓에 21번째 open_markdown 요청을 전송한다
Then:
  - 에러 응답: {"id":"...","error":{"message":"Maximum window limit (20) reached"}}
  - 새 창이 생성되지 않는다
```

---

## 8. 회귀 테스트 체크리스트

- [ ] `npx electron .` 실행 시 에러 없이 트레이 아이콘이 표시되고 소켓 서버가 리스닝 상태
- [ ] 소켓으로 `open_markdown` → `list_viewers` → `close_viewer` 순서대로 호출 시 모두 정상 응답
- [ ] 앱 실행 중 모든 창을 닫아도 프로세스가 종료되지 않음 (트레이 모드)
- [ ] 두 번째 인스턴스 실행 시 즉시 종료되고 첫 번째 인스턴스에 영향 없음

---

## 9. 테스트 코드 템플릿

```javascript
// test/phase2-electron-main.test.js (pseudocode)
const net = require('net');
const { spawn } = require('child_process');
const path = require('path');

const PIPE_PATH = process.platform === 'win32'
  ? '\\\\.\\pipe\\doclight-ipc'
  : '/tmp/doclight-ipc.sock';

function sendIpcRequest(socket, action, params = {}) {
  return new Promise((resolve, reject) => {
    const id = `test-${Date.now()}`;
    let buffer = '';

    const onData = (chunk) => {
      buffer += chunk.toString();
      const lines = buffer.split('\n');
      for (let i = 0; i < lines.length - 1; i++) {
        const response = JSON.parse(lines[i]);
        if (response.id === id) {
          socket.removeListener('data', onData);
          if (response.error) reject(new Error(response.error.message));
          else resolve(response.result);
        }
      }
      buffer = lines[lines.length - 1];
    };

    socket.on('data', onData);
    socket.write(JSON.stringify({ id, action, params }) + '\n');

    setTimeout(() => {
      socket.removeListener('data', onData);
      reject(new Error('IPC request timeout'));
    }, 5000);
  });
}

describe('Phase 2: Electron Main Process', () => {
  let electronProcess;
  let socket;

  beforeAll(async () => {
    // Electron 앱 시작 (headless는 불가하므로 실제 GUI 환경 필요)
    electronProcess = spawn('npx', ['electron', '.'], {
      cwd: path.resolve(__dirname, '..'),
      stdio: 'pipe'
    });

    // 소켓 서버 준비 대기 (최대 5초)
    await new Promise((resolve, reject) => {
      const maxAttempts = 10;
      let attempt = 0;
      const tryConnect = () => {
        socket = net.connect(PIPE_PATH, () => resolve());
        socket.on('error', () => {
          if (++attempt < maxAttempts) setTimeout(tryConnect, 500);
          else reject(new Error('Cannot connect to IPC socket'));
        });
      };
      tryConnect();
    });
  });

  afterAll(() => {
    socket?.destroy();
    electronProcess?.kill();
  });

  it('open_markdown으로 창을 열 수 있어야 한다', async () => {
    const result = await sendIpcRequest(socket, 'open_markdown', {
      content: '# Test Document\n\nHello from test',
      foreground: true
    });
    expect(result.windowId).toBeDefined();
    expect(result.title).toBe('Test Document');
  });

  it('list_viewers로 열린 창 목록을 조회할 수 있어야 한다', async () => {
    const result = await sendIpcRequest(socket, 'list_viewers');
    expect(result.windows).toBeInstanceOf(Array);
    expect(result.windows.length).toBeGreaterThanOrEqual(1);
    expect(result.windows[0]).toHaveProperty('windowId');
    expect(result.windows[0]).toHaveProperty('title');
  });

  it('close_viewer로 특정 창을 닫을 수 있어야 한다', async () => {
    // 먼저 창 열기
    const opened = await sendIpcRequest(socket, 'open_markdown', {
      content: '# To Close'
    });

    // 닫기
    const result = await sendIpcRequest(socket, 'close_viewer', {
      windowId: opened.windowId
    });
    expect(result.closed).toBe(1);

    // 목록에서 제거 확인
    const list = await sendIpcRequest(socket, 'list_viewers');
    const found = list.windows.find(w => w.windowId === opened.windowId);
    expect(found).toBeUndefined();
  });

  it('존재하지 않는 windowId에 대해 에러를 반환해야 한다', async () => {
    await expect(
      sendIpcRequest(socket, 'close_viewer', { windowId: 'nonexistent' })
    ).rejects.toThrow('Window not found');
  });

  it('모든 창을 닫아도 앱이 종료되지 않아야 한다', async () => {
    await sendIpcRequest(socket, 'close_viewer', {}); // 전체 닫기

    // 1초 대기 후 소켓 연결 확인 (앱이 살아있으면 연결 가능)
    await new Promise(resolve => setTimeout(resolve, 1000));
    const testSocket = net.connect(PIPE_PATH);
    await new Promise((resolve, reject) => {
      testSocket.on('connect', () => { testSocket.destroy(); resolve(); });
      testSocket.on('error', reject);
    });
  });
});
```

---

## 10. 파일 목록 및 예상 코드 크기

| 파일 | 예상 라인 수 | 핵심 책임 |
|------|-------------|-----------|
| `src/main/index.js` | ~200 | 앱 생명주기, 트레이, IPC 소켓 서버, IPC 핸들러 |
| `src/main/preload.js` | ~40 | contextBridge API 정의 |
| `src/main/window-manager.js` | ~250 | WindowManager 클래스, NavigationHistory 클래스 |
| **합계** | **~490** | |

---

## 11. 예상 소요 시간

| 작업 | 소요 시간 |
|------|-----------|
| index.js (생명주기 + 트레이 + IPC 서버) | 3시간 |
| preload.js | 30분 |
| window-manager.js (WindowManager + NavigationHistory) | 3시간 |
| IPC 핸들러 연결 + 통합 테스트 | 1.5시간 |
| 엣지케이스 처리 + 디버깅 | 1시간 |
| **합계** | **~9시간** |
