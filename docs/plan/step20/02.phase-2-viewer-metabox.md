# Phase 2: Viewer Frontmatter 파싱 및 메타박스 UI

## 목적

Viewer(renderer)에서 markdown content 상단의 YAML frontmatter를 파싱하여 접을 수 있는 메타박스(metabox) UI로 표시한다. frontmatter 내용은 `marked.parse()`에 전달하지 않아 렌더링 출력과 분리된다.

---

## 수정 대상 파일 목록

### 1. `src/renderer/viewer.js`

#### 1-1. frontmatter 파싱 함수 추가

**삽입 위치**: `renderMarkdown()` 함수 바로 위 (line 290 부근), 또는 `// === Rendering Pipeline ===` 주석 직전

```javascript
// === Frontmatter Parser ===

/**
 * Extract YAML frontmatter from markdown content.
 * Returns { meta: object|null, body: string }.
 * If no frontmatter found, meta is null and body is the original content.
 */
function parseFrontmatter(markdown) {
  const fmRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?/;
  const match = markdown.match(fmRegex);
  if (!match) {
    return { meta: null, body: markdown };
  }

  const yamlContent = match[1];
  const meta = {};

  for (const line of yamlContent.split(/\r?\n/)) {
    const m = line.match(/^(\w+)\s*:\s*(.*)$/);
    if (m) {
      const key = m[1];
      let value = m[2].trim();
      // Remove surrounding quotes
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      meta[key] = value;
    }
  }

  const body = markdown.slice(match[0].length);
  return { meta, body };
}
```

#### 1-2. 메타박스 렌더링 함수 추가

**삽입 위치**: `parseFrontmatter()` 바로 아래

```javascript
/**
 * Render the frontmatter metabox UI.
 * If meta is null, hides the metabox.
 *
 * @param {object|null} meta - Parsed frontmatter key-value pairs
 */
function renderMetabox(meta) {
  const metabox = document.getElementById('frontmatter-metabox');
  if (!metabox) return;

  if (!meta || Object.keys(meta).length === 0) {
    metabox.classList.add('hidden');
    return;
  }

  metabox.classList.remove('hidden');

  const contentEl = metabox.querySelector('.metabox-content');
  if (!contentEl) return;

  // Define display labels for known fields
  const fieldLabels = {
    project: t('viewer.metaProject'),
    docName: t('viewer.metaDocName'),
    description: t('viewer.metaDescription'),
    date: t('viewer.metaDate')
  };

  // Build table rows
  let html = '<table class="metabox-table">';
  for (const [key, value] of Object.entries(meta)) {
    const label = fieldLabels[key] || key;
    const escapedValue = escapeHtml(String(value));
    html += `<tr><td class="metabox-key">${escapeHtml(label)}</td><td class="metabox-value">${escapedValue}</td></tr>`;
  }
  html += '</table>';

  contentEl.innerHTML = html;
}

/**
 * Escape HTML special characters.
 */
function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}
```

> **참고**: `escapeHtml`이 이미 viewer.js에 존재하는지 확인. 없으면 위 함수를 추가한다.

#### 1-3. `renderMarkdown()` 함수 수정

**변경 위치**: `renderMarkdown()` 함수 내부 (line 291~336)

현재 코드:
```javascript
async function renderMarkdown(markdown) {
  const contentEl = document.getElementById('content');
  if (!contentEl) return;

  // Performance warning for large documents
  const size = new Blob([markdown]).size;
  // ...

  // Step 1: Parse markdown to HTML
  const rawHtml = marked.parse(markdown);
```

변경:
```javascript
async function renderMarkdown(markdown) {
  const contentEl = document.getElementById('content');
  if (!contentEl) return;

  // Step 0: Extract frontmatter (before markdown parsing)
  const { meta, body } = parseFrontmatter(markdown);
  renderMetabox(meta);

  // Use body (without frontmatter) for rendering
  const renderTarget = body;

  // Performance warning for large documents
  const size = new Blob([renderTarget]).size;
  if (size > 5 * 1024 * 1024) {
    showPerformanceWarning(size);
  }

  // Step 1: Parse markdown to HTML
  const rawHtml = marked.parse(renderTarget);
```

나머지 파이프라인(DOMPurify, DOM 삽입, 이미지 해상도, Mermaid, hljs, TOC)은 변경 없음.

#### 1-4. 메타박스 토글 이벤트 바인딩

**삽입 위치**: DOMContentLoaded 이벤트 핸들러 또는 초기화 부분

```javascript
// Metabox toggle (collapsible)
const metaboxToggle = document.querySelector('.metabox-toggle');
if (metaboxToggle) {
  metaboxToggle.addEventListener('click', () => {
    const metabox = document.getElementById('frontmatter-metabox');
    if (metabox) {
      metabox.classList.toggle('collapsed');
      const isCollapsed = metabox.classList.contains('collapsed');
      metaboxToggle.setAttribute('aria-expanded', String(!isCollapsed));
    }
  });
}
```

---

### 2. `src/renderer/viewer.html`

**변경 위치**: `<div id="viewer-container">` 내부, `<div id="content">` 바로 위에 메타박스 컨테이너 추가

현재 (line 33~35):
```html
<div id="viewer-container" role="tabpanel">
  <div id="content" class="markdown-body"></div>
</div>
```

변경:
```html
<div id="viewer-container" role="tabpanel">
  <!-- Frontmatter Metabox (Step 20) -->
  <div id="frontmatter-metabox" class="frontmatter-metabox hidden">
    <button class="metabox-toggle" aria-expanded="true" aria-controls="metabox-content-area">
      <svg class="metabox-toggle-icon" viewBox="0 0 24 24" width="14" height="14">
        <polyline points="6 9 12 15 18 9"/>
      </svg>
      <span class="metabox-title" data-i18n="viewer.metaboxTitle">Document Info</span>
    </button>
    <div class="metabox-content" id="metabox-content-area">
      <!-- Populated by viewer.js -->
    </div>
  </div>
  <div id="content" class="markdown-body"></div>
</div>
```

---

### 3. `src/renderer/viewer.css`

**삽입 위치**: 파일 끝 (기존 스타일 뒤에 추가)

```css
/* === Frontmatter Metabox (Step 20) === */
.frontmatter-metabox {
  margin: 0 auto;
  padding: 0;
  max-width: var(--content-max-width);
  width: var(--content-width);
}

.frontmatter-metabox.hidden {
  display: none;
}

.metabox-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  width: 100%;
  padding: 8px 2rem;
  background: var(--code-bg);
  border: none;
  border-bottom: 1px solid var(--border-color);
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  color: var(--muted-text);
  text-align: left;
  transition: background 150ms;
}

.metabox-toggle:hover {
  background: var(--sidebar-hover);
}

.metabox-toggle-icon {
  fill: none;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: transform 200ms ease;
  flex-shrink: 0;
}

.frontmatter-metabox.collapsed .metabox-toggle-icon {
  transform: rotate(-90deg);
}

.metabox-content {
  padding: 8px 2rem;
  background: var(--code-bg);
  border-bottom: 1px solid var(--border-color);
  overflow: hidden;
  transition: max-height 200ms ease, padding 200ms ease;
}

.frontmatter-metabox.collapsed .metabox-content {
  max-height: 0;
  padding-top: 0;
  padding-bottom: 0;
  border-bottom: none;
}

.metabox-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

.metabox-table tr {
  border-bottom: 1px solid var(--border-color);
}

.metabox-table tr:last-child {
  border-bottom: none;
}

.metabox-key {
  padding: 4px 12px 4px 0;
  font-weight: 600;
  color: var(--muted-text);
  white-space: nowrap;
  width: 1%;
  vertical-align: top;
}

.metabox-value {
  padding: 4px 0;
  color: var(--text-color);
  word-break: break-word;
}

/* Dark theme adjustments */
[data-theme="dark"] .metabox-toggle {
  background: var(--code-bg);
}

[data-theme="dark"] .metabox-toggle:hover {
  background: var(--sidebar-hover);
}

[data-theme="dark"] .metabox-content {
  background: var(--code-bg);
}
```

---

### 4. `src/locales/ko.json`

**추가할 키** (기존 `viewer.` 섹션 끝에 추가):

```json
"viewer.metaboxTitle": "문서 정보",
"viewer.metaProject": "프로젝트",
"viewer.metaDocName": "문서 이름",
"viewer.metaDescription": "설명",
"viewer.metaDate": "날짜"
```

**삽입 위치**: `"viewer.copy": "복사"` 바로 뒤 (line 121 이후)

---

### 5. `src/locales/en.json`

```json
"viewer.metaboxTitle": "Document Info",
"viewer.metaProject": "Project",
"viewer.metaDocName": "Document Name",
"viewer.metaDescription": "Description",
"viewer.metaDate": "Date"
```

---

### 6. `src/locales/ja.json`

```json
"viewer.metaboxTitle": "ドキュメント情報",
"viewer.metaProject": "プロジェクト",
"viewer.metaDocName": "ドキュメント名",
"viewer.metaDescription": "説明",
"viewer.metaDate": "日付"
```

---

### 7. `src/locales/es.json`

```json
"viewer.metaboxTitle": "Informacion del documento",
"viewer.metaProject": "Proyecto",
"viewer.metaDocName": "Nombre del documento",
"viewer.metaDescription": "Descripcion",
"viewer.metaDate": "Fecha"
```

---

## 메타박스 동작 상세

### 표시 조건

- frontmatter가 존재하고 1개 이상의 필드가 파싱되면 메타박스 표시
- frontmatter가 없으면 메타박스 숨김 (`hidden` 클래스)
- 빈 frontmatter (`---\n---`)도 숨김

### 토글 동작

- 기본 상태: **펼침(open)** — `collapsed` 클래스 없음
- 토글 버튼 클릭 시 `collapsed` 클래스 토글
- CSS `max-height` 트랜지션으로 부드러운 접기/펼치기
- 화살표 아이콘 회전 (펼침: 아래, 접힘: 오른쪽)

### 필드 표시 순서

모든 frontmatter 필드를 키 순서대로 표시. 알려진 필드(`project`, `docName`, `description`, `date`)는 번역된 라벨 사용. 미등록 필드는 키 이름을 그대로 표시.

### update-markdown 처리

`update-markdown` IPC 수신 시에도 `renderMarkdown()`이 호출되므로 메타박스 자동 갱신. 별도 처리 불필요.

### PDF 모드

PDF 내보내기 모드(`data.pdfMode`)에서는 메타박스를 숨김 처리. 기존 PDF 모드에서 `floatingBtns`, `sidebar` 등을 숨기는 로직과 동일하게 처리.

**변경 위치**: viewer.js의 PDF 모드 처리 부분 (line 402~415)

```javascript
if (data.pdfMode) {
  // ... 기존 숨김 ...
  const metabox = document.getElementById('frontmatter-metabox');
  if (metabox) metabox.style.display = 'none';
}
```

---

## 테스트 시나리오

### T1: frontmatter 있는 content → 메타박스 표시
- open_markdown으로 frontmatter 포함 content 전송
- 기대: 메타박스가 content 상단에 표시, 모든 필드 테이블로 렌더링
- content 영역에는 frontmatter 텍스트 미표시

### T2: frontmatter 없는 content → 메타박스 숨김
- open_markdown으로 frontmatter 없는 content 전송
- 기대: 메타박스 `hidden` 상태

### T3: 메타박스 접기/펼치기
- 메타박스 토글 버튼 클릭
- 기대: content 영역이 접혀서 숨김, 아이콘 회전
- 다시 클릭 시 펼침

### T4: Dark 테마에서 정상 표시
- 설정에서 Dark 테마 적용
- 기대: 메타박스 배경, 텍스트 색상이 다크 테마에 맞게 표시

### T5: update-markdown으로 frontmatter 변경
- open_markdown → frontmatter 포함 content
- update_markdown → 다른 frontmatter 포함 content
- 기대: 메타박스 내용 갱신

### T6: update-markdown으로 frontmatter 제거
- open_markdown → frontmatter 포함 content
- update_markdown → frontmatter 없는 content
- 기대: 메타박스 숨김

### T7: 알 수 없는 frontmatter 필드 표시
- content: `---\nproject: P1\ncustomField: value\n---`
- 기대: `customField`는 키 이름 그대로 표시

### T8: i18n 확인
- 로케일을 en, ko, ja, es로 각각 변경
- 기대: 메타박스 제목, 필드 라벨이 해당 언어로 표시

### T9: PDF 모드에서 메타박스 숨김
- PDF 내보내기 실행
- 기대: 메타박스가 PDF 출력에 포함되지 않음

### T10: 대용량 frontmatter description
- description에 200자 이상 긴 텍스트 제공
- 기대: `word-break: break-word`로 줄바꿈 정상 처리

---

## 완료 기준

1. [x] frontmatter 파싱 함수 정상 동작 (존재/미존재 케이스)
2. [x] 메타박스 UI 표시/숨김 정상 동작
3. [x] 접기/펼치기 토글 정상 동작 (기본: 펼침)
4. [x] Light/Dark 테마 모두 정상 표시
5. [x] frontmatter가 marked.parse()에 전달되지 않음
6. [x] 4개 로케일 문자열 추가 완료 (ko, en, ja, es)
7. [x] PDF 모드에서 메타박스 숨김
8. [x] update-markdown 시 메타박스 갱신
