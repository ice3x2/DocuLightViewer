# Phase 1: MCP 파라미터 추가 + Frontmatter 자동 조합

## 목적

MCP `open_markdown` 및 `update_markdown` 툴에 `project`, `docName`, `description` 파라미터를 추가하고, 이 값들이 존재할 때 YAML frontmatter를 자동으로 조합하여 content 상단에 주입한다.

---

## 수정 대상 파일 목록

### 1. `src/main/mcp-server.mjs`

**변경 위치**: `open_markdown` 툴 Zod 스키마 (line 328~339)

**추가할 파라미터**:
```javascript
project:     z.string().optional().describe('Project name for frontmatter metadata (e.g., "DocuLight")'),
docName:     z.string().optional().describe('Document name/identifier for frontmatter metadata (e.g., "API Reference")'),
description: z.string().optional().describe('Document description/summary for frontmatter metadata. STRONGLY RECOMMENDED: Always provide a brief summary of the document content.'),
```

**삽입 위치**: `noSave` 파라미터 바로 위 (line 339 이전), 즉 기존 파라미터 블록 끝에 추가.

**변경 위치**: `open_markdown` 핸들러 함수 시그니처 (line 341)

현재:
```javascript
async ({ content, filePath, title, foreground, size,
         windowName, severity, tags, flash, progress, autoCloseSeconds, noSave }) => {
```

변경:
```javascript
async ({ content, filePath, title, foreground, size,
         windowName, severity, tags, flash, progress, autoCloseSeconds, noSave,
         project, docName, description }) => {
```

**frontmatter 조합 로직 삽입 위치**: 유효성 검증 후, `sendIpcRequest` 호출 전 (line 362 이전)

```javascript
// --- Frontmatter injection ---
if (content && (project || docName || description)) {
  content = injectFrontmatter(content, { project, docName, description });
}
```

**IPC 요청에 파라미터 전달** (line 363~368):
기존 `sendIpcRequest` 호출에 `project`, `docName`, `description`을 추가할 필요 없음. frontmatter는 content에 이미 주입되었으므로 content만 전달하면 된다. 단, `filePath`만 제공된 경우를 위해 파라미터를 IPC에도 전달해야 한다.

```javascript
const result = await sendIpcRequest('open_markdown', {
  content, filePath, title,
  foreground: foreground ?? true,
  size: size ?? 'm',
  windowName, severity, tags, flash, progress, autoCloseSeconds, noSave,
  project, docName, description
});
```

---

**변경 위치**: `update_markdown` 툴 Zod 스키마 (line 399~411)

동일한 3개 파라미터 추가:
```javascript
project:     z.string().optional().describe('Project name for frontmatter metadata'),
docName:     z.string().optional().describe('Document name/identifier for frontmatter metadata'),
description: z.string().optional().describe('Document description/summary for frontmatter metadata. STRONGLY RECOMMENDED.'),
```

**변경 위치**: `update_markdown` 핸들러 함수 시그니처 (line 413~414)

`project, docName, description` 추가.

**frontmatter 조합 로직**: `open_markdown`과 동일하게, content가 있고 메타데이터 파라미터가 있으면 주입.

```javascript
if (content && (project || docName || description)) {
  content = injectFrontmatter(content, { project, docName, description });
}
```

**IPC 요청에 전달** (line 434~436):
```javascript
const result = await sendIpcRequest('update_markdown', {
  windowId, content, filePath, title, appendMode, separator,
  severity, tags, flash, progress, autoCloseSeconds, noSave,
  project, docName, description
});
```

---

**신규 함수 추가**: `injectFrontmatter()` — 파일 상단에 헬퍼 함수로 정의

**삽입 위치**: `// Helpers` 섹션 (line 49~52 부근) 또는 MCP Server 섹션 직전

```javascript
// =============================================================================
// Frontmatter Helpers
// =============================================================================

/**
 * Inject or merge YAML frontmatter into markdown content.
 *
 * If content already has a frontmatter block (---\n...\n---), the new metadata
 * fields are merged in (new values take priority). Otherwise, a new frontmatter
 * block is prepended.
 *
 * @param {string} content - Raw markdown content
 * @param {object} meta - Metadata fields to inject
 * @param {string} [meta.project]
 * @param {string} [meta.docName]
 * @param {string} [meta.description]
 * @returns {string} Content with frontmatter prepended/merged
 */
function injectFrontmatter(content, { project, docName, description }) {
  const newFields = {};
  if (project) newFields.project = project;
  if (docName) newFields.docName = docName;
  if (description) newFields.description = description;
  newFields.date = new Date().toISOString().replace(/\.\d{3}Z$/, '');

  // Check if content already has frontmatter
  const fmRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?/;
  const match = content.match(fmRegex);

  if (match) {
    // Parse existing frontmatter (simple key: value YAML)
    const existingFields = parseSimpleYaml(match[1]);
    // Merge: new values override existing
    const merged = { ...existingFields, ...newFields };
    const yamlBlock = buildYamlBlock(merged);
    return yamlBlock + content.slice(match[0].length);
  }

  // No existing frontmatter: prepend new block
  const yamlBlock = buildYamlBlock(newFields);
  return yamlBlock + content;
}

/**
 * Parse simple YAML key-value pairs (no nesting, no arrays).
 * Handles quoted and unquoted string values.
 *
 * @param {string} yaml - Raw YAML content (without --- delimiters)
 * @returns {object} Parsed key-value pairs
 */
function parseSimpleYaml(yaml) {
  const result = {};
  for (const line of yaml.split(/\r?\n/)) {
    const m = line.match(/^(\w+)\s*:\s*(.*)$/);
    if (m) {
      const key = m[1];
      let value = m[2].trim();
      // Remove surrounding quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      result[key] = value;
    }
  }
  return result;
}

/**
 * Build a YAML frontmatter block string from key-value pairs.
 *
 * @param {object} fields - Key-value pairs
 * @returns {string} Complete frontmatter block with --- delimiters and trailing newline
 */
function buildYamlBlock(fields) {
  const lines = ['---'];
  for (const [key, value] of Object.entries(fields)) {
    if (value === undefined || value === null || value === '') continue;
    // Quote values that contain special YAML characters
    const needsQuote = /[:#\[\]{}&*!|>'"`,@%]/.test(String(value)) ||
                       String(value).includes('\n');
    const formatted = needsQuote
      ? `"${String(value).replace(/"/g, '\\"')}"`
      : String(value);
    lines.push(`${key}: ${formatted}`);
  }
  lines.push('---');
  lines.push('');
  return lines.join('\n');
}
```

---

### 2. `src/main/mcp-http.mjs`

**변경 위치**: `TOOLS` 배열 > `open_markdown` > `inputSchema.properties` (line 102~116)

**추가할 속성**:
```javascript
project:     { type: 'string', description: 'Project name for frontmatter metadata (e.g., "DocuLight")' },
docName:     { type: 'string', description: 'Document name/identifier for frontmatter metadata (e.g., "API Reference")' },
description: { type: 'string', description: 'Document description/summary for frontmatter metadata. STRONGLY RECOMMENDED: Always provide a brief summary of the document content.' },
```

**삽입 위치**: `noSave` 속성 위에 (line 115 이전)

---

**변경 위치**: `TOOLS` 배열 > `update_markdown` > `inputSchema.properties` (line 124~136)

동일 3개 속성 추가.

---

**변경 위치**: `createToolHandlers()` > `open_markdown` 핸들러 (line 170~171)

함수 시그니처에 `project, docName, description` 추가:
```javascript
async open_markdown({ content, filePath, title, foreground, alwaysOnTop, size,
                      windowName, severity, tags, flash, progress, autoCloseSeconds, noSave,
                      project, docName, description }) {
```

**frontmatter 조합 로직 삽입**: 유효성 검증 후, `windowManager.createWindow()` 호출 전 (line 178 이전)

```javascript
// Frontmatter injection
if (content && (project || docName || description)) {
  content = injectFrontmatter(content, { project, docName, description });
}
```

> **참고**: `injectFrontmatter`, `parseSimpleYaml`, `buildYamlBlock` 함수를 `mcp-http.mjs`에도 별도로 정의해야 한다. 두 파일은 별도 프로세스에서 실행되므로 (stdio MCP vs embedded HTTP) 코드를 공유할 수 없다. 동일한 함수를 복사하거나, 공용 모듈 파일(`src/main/frontmatter.mjs`)로 분리하는 방안도 가능하다.

**권장 구조**: `src/main/frontmatter.mjs`로 분리

```
src/main/frontmatter.mjs  ← 신규 파일 (ESM)
  export { injectFrontmatter, parseSimpleYaml, buildYamlBlock }
```

- `mcp-server.mjs`에서: `import { injectFrontmatter } from './frontmatter.mjs';`
- `mcp-http.mjs`에서: `import { injectFrontmatter } from './frontmatter.mjs';`

---

**변경 위치**: `createToolHandlers()` > `update_markdown` 핸들러 (line 228~229)

함수 시그니처에 `project, docName, description` 추가.

frontmatter 조합 로직 삽입 (content 처리 전):
```javascript
if (content && (project || docName || description)) {
  content = injectFrontmatter(content, { project, docName, description });
}
```

---

### 3. `src/main/window-manager.js`

**변경 사항: 최소화 (pass-through)**

현재 `createWindow()`와 `updateWindow()`는 `content`를 직접 받아서 renderer에 전달한다. frontmatter는 이미 MCP 레이어에서 content에 주입되므로 window-manager에서는 추가 처리가 불필요하다.

단, `filePath`만 제공된 경우(디스크에서 읽기)에는 MCP에서 주입할 수 없으므로 파라미터를 전달해야 한다.

**변경 위치**: `createWindow()` 함수 (line 263~266)

opts destructuring에 `project, docName, description` 추가:
```javascript
const { foreground, title: explicitTitle, size, windowName,
        severity, tags, flash, progress, autoCloseSeconds,
        project, docName, description } = opts;
```

**filePath 읽기 후 frontmatter 주입** (line 288 이후, content 읽기 완료 후):

```javascript
if (filePath) {
  // ... 기존 파일 읽기 ...
  content = await fs.promises.readFile(filePath, 'utf-8');

  // Inject frontmatter if metadata params provided (filePath mode)
  if (project || docName || description) {
    const { injectFrontmatter } = require('./frontmatter.cjs');
    content = injectFrontmatter(content, { project, docName, description });
  }
}
```

> **참고**: window-manager.js는 CJS이므로 `frontmatter.mjs`를 직접 import할 수 없다. 두 가지 옵션:
> 1. CJS용 래퍼 `frontmatter.cjs` 작성
> 2. frontmatter 로직을 순수 CJS 함수로 작성하여 `frontmatter.js`로 만들고 양쪽에서 사용
>
> **권장**: `src/main/frontmatter.js` (CJS)로 작성하고, ESM 파일들에서는 `import { createRequire } from 'module'`로 로드하거나, 동일 로직을 ESM으로 `frontmatter.mjs`에도 복제.
>
> **최종 결정**: 코드 중복을 피하기 위해 `src/main/frontmatter.js` (CJS)로 작성하고:
> - `window-manager.js`: `const { injectFrontmatter } = require('./frontmatter');`
> - `mcp-server.mjs`: `import { createRequire } from 'module'; const require = createRequire(import.meta.url); const { injectFrontmatter } = require('./frontmatter.js');`
> - `mcp-http.mjs`: 동일

**변경 위치**: `updateWindow()` 함수 (line 625~632)

opts에서 `project, docName, description` 추출:
```javascript
let { content, filePath, title, appendMode, separator,
      severity, flash, progress, tags, autoCloseSeconds,
      project, docName, description } = opts;
```

filePath 읽기 후 동일 주입 로직:
```javascript
if (filePath) {
  // ... 기존 파일 읽기 ...
  content = await fs.promises.readFile(filePath, 'utf-8');

  if (project || docName || description) {
    const { injectFrontmatter } = require('./frontmatter');
    content = injectFrontmatter(content, { project, docName, description });
  }
}
```

---

### 4. `src/main/index.js`

**변경 사항: 없음 (자동 전파)**

현재 `handleIpcMessage()`에서 `open_markdown` 액션은 `params`를 그대로 `windowManager.createWindow(params)`에 전달한다 (line 657). `update_markdown`도 마찬가지로 `params`를 통째로 전달한다 (line 676).

따라서 MCP 서버에서 IPC 요청에 `project`, `docName`, `description`을 포함하면 자동으로 window-manager까지 전파된다. **index.js 자체는 수정 불필요**.

---

### 5. `src/main/frontmatter.js` (신규 파일)

CJS 모듈로 frontmatter 조합 로직을 공용화.

```javascript
// src/main/frontmatter.js — Frontmatter injection utility (CJS)
'use strict';

/**
 * Inject or merge YAML frontmatter into markdown content.
 */
function injectFrontmatter(content, { project, docName, description }) {
  const newFields = {};
  if (project) newFields.project = project;
  if (docName) newFields.docName = docName;
  if (description) newFields.description = description;
  newFields.date = new Date().toISOString().replace(/\.\d{3}Z$/, '');

  const fmRegex = /^---\r?\n([\s\S]*?)\r?\n---\r?\n?/;
  const match = content.match(fmRegex);

  if (match) {
    const existingFields = parseSimpleYaml(match[1]);
    const merged = { ...existingFields, ...newFields };
    const yamlBlock = buildYamlBlock(merged);
    return yamlBlock + content.slice(match[0].length);
  }

  const yamlBlock = buildYamlBlock(newFields);
  return yamlBlock + content;
}

function parseSimpleYaml(yaml) {
  const result = {};
  for (const line of yaml.split(/\r?\n/)) {
    const m = line.match(/^(\w+)\s*:\s*(.*)$/);
    if (m) {
      const key = m[1];
      let value = m[2].trim();
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }
      result[key] = value;
    }
  }
  return result;
}

function buildYamlBlock(fields) {
  const lines = ['---'];
  for (const [key, value] of Object.entries(fields)) {
    if (value === undefined || value === null || value === '') continue;
    const needsQuote = /[:#\[\]{}&*!|>'"`,@%]/.test(String(value)) ||
                       String(value).includes('\n');
    const formatted = needsQuote
      ? `"${String(value).replace(/"/g, '\\"')}"`
      : String(value);
    lines.push(`${key}: ${formatted}`);
  }
  lines.push('---');
  lines.push('');
  return lines.join('\n');
}

module.exports = { injectFrontmatter, parseSimpleYaml, buildYamlBlock };
```

---

## 구체적 코드 변경 요약

| 파일 | 변경 유형 | 내용 |
|------|-----------|------|
| `src/main/frontmatter.js` | **신규** | `injectFrontmatter()`, `parseSimpleYaml()`, `buildYamlBlock()` CJS 모듈 |
| `src/main/mcp-server.mjs` | 수정 | Zod 스키마에 3개 파라미터 추가, 핸들러에 frontmatter 조합 호출, IPC 전달 |
| `src/main/mcp-http.mjs` | 수정 | JSON Schema에 3개 속성 추가, 핸들러에 frontmatter 조합 호출 |
| `src/main/window-manager.js` | 수정 | createWindow/updateWindow에서 filePath 모드일 때 frontmatter 주입 |
| `src/main/index.js` | **변경 없음** | params 자동 전파로 수정 불필요 |

---

## Frontmatter 조합 로직 상세

### 케이스 1: content만 제공 + 메타데이터 있음

```
호출: open_markdown({ content: "# Hello\nWorld", project: "MyApp", description: "인사 문서" })

MCP 서버에서:
  content = injectFrontmatter(content, { project: "MyApp", description: "인사 문서" })

결과 content:
  ---
  project: MyApp
  description: "인사 문서"
  date: 2026-02-27T14:30:00
  ---
  # Hello
  World
```

### 케이스 2: filePath만 제공 + 메타데이터 있음

```
호출: open_markdown({ filePath: "/docs/readme.md", project: "MyApp" })

MCP 서버에서:
  content가 없으므로 주입 스킵 → IPC에 project 파라미터 전달

window-manager에서:
  파일 읽기 → content 획득 → injectFrontmatter() 호출
```

### 케이스 3: content에 이미 frontmatter 존재 + 새 메타데이터

```
호출: open_markdown({
  content: "---\ntitle: Old Title\nauthor: Kim\n---\n# Content",
  project: "NewProject"
})

결과:
  ---
  title: Old Title
  author: Kim
  project: NewProject
  date: 2026-02-27T14:30:00
  ---
  # Content
```

기존 `title`과 `author`는 보존, `project`와 `date`가 추가됨.

### 케이스 4: 메타데이터 파라미터 없음 → 동작 없음

```
호출: open_markdown({ content: "# Hello" })

결과: content 변경 없음 (기존 동작 유지)
```

### 케이스 5: appendMode + 메타데이터

appendMode에서는 frontmatter를 주입하지 않는다. appendMode는 기존 content에 추가하는 것이므로 frontmatter는 최초 호출 시에만 의미가 있다.

```javascript
// MCP 핸들러에서:
if (content && !appendMode && (project || docName || description)) {
  content = injectFrontmatter(content, { project, docName, description });
}
```

---

## 테스트 시나리오

### T1: content + 메타데이터 3개 모두 제공
- open_markdown 호출: content="# Test", project="P1", docName="Doc1", description="테스트"
- 기대: content 상단에 YAML frontmatter 블록 포함 (4개 필드: project, docName, description, date)
- Viewer에서 정상 렌더링 확인

### T2: content + 메타데이터 1개만 제공
- open_markdown 호출: content="# Test", description="요약"
- 기대: frontmatter에 description, date만 포함

### T3: filePath + 메타데이터
- open_markdown 호출: filePath="test.md", project="P1"
- 기대: 파일 내용 상단에 frontmatter 주입

### T4: 기존 frontmatter 병합
- open_markdown 호출: content="---\nauthor: Kim\n---\n# Test", project="P1"
- 기대: author 보존, project 추가, date 추가

### T5: 메타데이터 없으면 변경 없음
- open_markdown 호출: content="# Test" (project/docName/description 모두 미제공)
- 기대: content 그대로 전달

### T6: update_markdown + 메타데이터
- update_markdown 호출: windowId="...", content="# Updated", project="P1"
- 기대: 업데이트된 content에 frontmatter 포함

### T7: appendMode에서는 frontmatter 주입 안 함
- update_markdown 호출: appendMode=true, content="추가 내용", project="P1"
- 기대: frontmatter 주입 없이 content만 append

### T8: HTTP MCP (mcp-http.mjs) 동일 동작 확인
- HTTP POST로 open_markdown 호출 with 메타데이터
- 기대: stdio MCP와 동일한 frontmatter 주입

---

## 완료 기준

1. [x] `src/main/frontmatter.js` 신규 파일 생성 및 단위 테스트 통과
2. [x] `mcp-server.mjs`에 3개 파라미터 추가, frontmatter 조합 동작 확인
3. [x] `mcp-http.mjs`에 동일 파라미터 추가, frontmatter 조합 동작 확인
4. [x] `window-manager.js`에서 filePath 모드 frontmatter 주입 동작 확인
5. [x] 기존 frontmatter 병합 정상 동작
6. [x] 메타데이터 미제공 시 기존 동작 변경 없음
7. [x] appendMode에서 frontmatter 주입 스킵
8. [x] `npm start`로 앱 실행 시 에러 없음
